<!DOCTYPE html>
<html lang="en">

<head>
    <title>Command Reference</title>

    <!-- meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0 , minimal-ui">
    <meta name="AidEnviroment, PinniSOFT">
    <meta name="web_author" content="Not-for-profit sustainability strategy organisation">
    <meta name="format-detection" content="telephone=no">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta http-equiv="cleartype" content="on">
    <meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">
    <meta name="description"
        content="We are a not-for-profit sustainability research, strategy and implementation organisation working to achieve transformative sector change.">


    <script>
        // Initialize Font Awesome
        window.FontAwesomeConfig = { autoReplaceSvg: 'nest' };
    </script>
    <script src="assets\\fontawesome-free-6.4.2-web\\js\\all.min.js"></script>



    <!-- links -->
    <link rel="stylesheet" href="assets/links/bootstrap.min.css">
    <link rel="stylesheet" href="assets/fontawesome-free-6.4.2-web/css/brands.css">
    <link rel="stylesheet" href="assets/fontawesome-free-6.4.2-web/css/fontawesome.css">
    <link rel="stylesheet" href="assets/fontawesome-free-6.4.2-web/css/solid.css">

    <link rel="stylesheet" href="assets/links/bootstrap.min.css">
    <link rel="stylesheet" href="assets/css/font.css">
    <link rel="stylesheet" href="assets/css/mapshaper.css">

    <link rel="stylesheet" href="assets/franklin-gothic-cufonfonts/work.css">
    <link rel="stylesheet" href="assets/franklin-gothic-cufonfonts/work2.css">

    <script src="assets/links/jquery.min.js"></script>
    <script src="assets/links/popper.min.js"></script>
    <script src="assets/links/bootstrap.bundle.min.js"></script>

    <link rel="icon" type="image/x-icon" href="assets/pics/favicon.ico">
    <style>
        body {

            background-color: #ffffff;
            margin: 0;

            color: #333;
        }

        .main {
            padding: 30px;
            padding-top: 100px;
        }

        h1,
        h2,
        h3 {
            color: #333;
        }

        h6,
        h4 {
            font-weight: bold;
        }

        h2 {
            border-bottom: #000 2px solid;
        }

        h4 {
            border-bottom: #333 2px thin;
        }

        .main .title {
            border-bottom: 2px thin #333;
        }


        p {
            color: #000;
            margin-bottom: 10px;
        }

        img {
            max-width: 100%;
            height: auto;
            margin-bottom: 15px;
            border-radius: 5px;
            /* box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); */
        }

        ul {
            list-style-type: disc;
            padding-left: 40px;
        }

        li {
            margin-bottom: 5px;
        }

        pre {
            background-color: #f1f1f1;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        code {
            padding: 2px 5px;
            border-radius: 3px;
        }
    </style>

</head>

<body>

    <header class="header-container">

        <nav class="navbar navbar-expand-lg fixed-top navbar-light custom-navbar">
            <div class="logo">
                <a class="navbar-brand" href="command-line-tool.html">
                    <img src="assets/pics/aidlogo.png" alt="Logo">

                </a>
            </div>

            <button class="navbar-toggler p-0 border-0" type="button" data-toggle="offcanvas">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="navbar-collapse offcanvas-collapse" id="navbarNav">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item" id="nav-item">
                        <a class="nav-link" href="command-line-tool.html">Command Line Tool</a>
                    </li>
                    <li class="nav-item" id="nav-item">
                        <a class="nav-link active" href="command-reference.html">Command Reference</a>
                    </li>
                    <li class="nav-item" id="nav-item">
                        <a class="nav-link" href="simplification.html">Simplification</a>
                    </li>
                    <li class="nav-item" id="nav-item">
                        <a class="nav-link" href="topotopy.html">Topotopy</a>
                    </li>
                    <li class="nav-item" id="nav-item">
                        <a class="nav-link" href="tutoial.html">Tutorial</a>
                    </li>
                    <li class="nav-item" id="nav-item">
                        <a class="nav-link" href="web-interface.html">Web Interface</a>
                    </li>
                    <li class="nav-item" id="nav-item">
                        <a class="nav-link" href="using-shapefiles.html">Using Shapefiles</a>
                    </li>
                    <li class="nav-item" id="nav-item">
                        <a class="nav-link" href="topojson.html">TopoJSON Client</a>
                    </li>
                </ul>
            </div>
        </nav>
    </header>
    <main class="main">


        <h1 id="command-reference">COMMAND REFERENCE</h1>
        <p>This documentation applies to version 0.6.60 of mapshaper&#39;s command line program. Run
            <code>mapshaper -v</code> to check your version. For an introduction to the command line tool, read <a
                href="command-line-tool.html">this page</a>
            first.</p>
        <h2 id="command-line-syntax">Command line syntax</h2>
        <p>Mapshaper takes a list of commands and runs them in sequence, from left to right. A command consists of the
            name of a command prefixed by a hyphen, followed by options for the command. The initial import command
            <code>-i</code> can be omitted.</p>
        <h4 id="example">Example</h4>
        <pre><code class="lang-bash"># Read <span class="hljs-keyword">a</span> Shapefile, <span class="hljs-built_in">simplify</span> using Douglas-Peucker, output <span class="hljs-keyword">as</span> GeoJSON.
        mapshaper provinces.shp -<span class="hljs-built_in">simplify</span> <span class="hljs-keyword">dp</span> <span class="hljs-number">20</span>% -<span class="hljs-keyword">o</span> precision=<span class="hljs-number">0.00001</span> output.geojson
        </code></pre>
        <h3 id="command-options-can-take-three-forms-">Command options can take three forms:</h3>
        <ul>
            <li>
                <p>Values, like <code>provinces.shp</code> and <code>output.geojson</code> in the above example</p>
            </li>
            <li>
                <p>Flags, like <code>dp</code></p>
            </li>
            <li>
                <p>Name/value pairs, like <code>precision=0.00001</code></p>
            </li>
        </ul>
        <h3 id="common-options">Common options</h3>
        <p>The following options are documented here, because they are used by many commands.</p>
        <p><code>name=</code> Rename the layer (or layers) modified by a command.</p>
        <p><code>target=</code> Specify the layer or layers targeted by a command. Takes the name of a layer, the number
            of a layer (first layer is 1), or a comma-separated list of layer names or numbers. Names may contain the
            <code>*</code> wildcard.</p>
        <p><code>+</code> Use the output of a command to create a new layer or layers instead of replacing the target
            layer(s). Use together with the <code>name=</code> option to assign a name to the new layer(s).</p>
        <h4 id="example">Example</h4>
        <pre><code class="lang-bash"><span class="hljs-comment"># Make a derived layer containing a subset of features while retaining the original layer</span>
        mapshaper states.geojson -filter '<span class="hljs-attr">ST</span> == <span class="hljs-string">"AK"</span>' + <span class="hljs-attr">name=alaska</span> -o output/ <span class="hljs-attr">target=*</span>
        </code></pre>
        <h2 id="index-of-commands">Index of commands</h2>
        <p><strong>File I/O</strong></p>
        <p><a href="#-i-input">-i (input)</a>
            <a href="#-o-output">-o (output)</a>
        </p>
        <p><strong>Editing</strong></p>
        <p><a href="#-affine">-affine</a>
            <a href="#-classify">-classify</a>
            <a href="#-clean">-clean</a>
            <a href="#-clip">-clip</a>
            <a href="#-colorizer">-colorizer</a>
            <a href="#-dashlines">-dashlines</a>
            <a href="#-dissolve">-dissolve</a>
            <a href="#-dissolve2">-dissolve2</a>
            <a href="#-divide">-divide</a>
            <a href="#-dots">-dots</a>
            <a href="#-drop">-drop</a>
            <a href="#-each">-each</a>
            <a href="#-erase">-erase</a>
            <a href="#-explode">-explode</a>
            <a href="#-filter">-filter</a>
            <a href="#-filter-fields">-filter-fields</a>
            <a href="#-filter-islands">-filter-islands</a>
            <a href="#-filter-slivers">-filter-slivers</a>
            <a href="#-graticule">-graticule</a>
            <a href="#-grid">-grid</a>
            <a href="#-include">-include</a>
            <a href="#-inlay">-inlay</a>
            <a href="#-innerlines">-innerlines</a>
            <a href="#-join">-join</a>
            <a href="#-lines">-lines</a>
            <a href="#-merge-layers">-merge-layers</a>
            <a href="#-mosaic">-mosaic</a>
            <a href="#-point-grid">-point-grid</a>
            <a href="#-points">-points</a>
            <a href="#-polygons">-polygons</a>
            <a href="#-proj">-proj</a>
            <a href="#-rectangle">-rectangle</a>
            <a href="#-rectangles">-rectangles</a>
            <a href="#-rename-fields">-rename-fields</a>
            <a href="#-rename-layers">-rename-layers</a>
            <a href="#-require">-require</a>
            <a href="#-run">-run</a>
            <a href="#-scalebar">-scalebar</a>
            <a href="#-shape">-shape</a>
            <a href="#-simplify">-simplify</a>
            <a href="#-snap">-snap</a>
            <a href="#-sort">-sort</a>
            <a href="#-split">-split</a>
            <a href="#-split-on-grid">-split-on-grid</a>
            <a href="#-subdivide">-subdivide</a>
            <a href="#-style">-style</a>
            <a href="#-symbols">-symbols</a>
            <a href="#-union">-union</a>
            <a href="#-uniq">-uniq</a>
        </p>
        <p><strong>Control Flow</strong></p>
        <p><a href="#-if">-if</a>
            <a href="#-elif">-elif</a>
            <a href="#-else">-else</a>
            <a href="#-endif">-endif</a>
            <a href="#-stop">-stop</a>
            <a href="#-target">-target</a>
        </p>
        <p><strong>Information</strong></p>
        <p><a href="#-calc">-calc</a>
            <a href="#-colors">-colors</a>
            <a href="#-comment">-comment</a>
            <a href="#-encodings">-encodings</a>
            <a href="#-help">-help</a>
            <a href="#-info">-info</a>
            <a href="#-inspect">-inspect</a>
            <a href="#-print">-print</a>
            <a href="#-projections">-projections</a>
            <a href="#-quiet">-quiet</a>
            <a href="#-verbose">-verbose</a>
            <a href="#-version">-version</a>
        </p>
        <h2 id="i-o-commands">I/O Commands</h2>
        <h3 id="-i-input-">-i (input)</h3>
        <p>Input one or more files in Shapefile, JSON, DBF or delimited text format.</p>
        <p>The <code>-i</code> command is assumed if <code>mapshaper</code> is followed by an input filename.</p>
        <p>JSON files can be GeoJSON, TopoJSON, or an array of data records.</p>
        <p>Each named geometry object of a TopoJSON input file is imported as a separate layer.</p>
        <p>Mapshaper does not fully support M and Z type Shapefiles. The M and Z data is lost when these files are
            imported.</p>
        <p>By default, multiple input files are processed separately, as if running mapshaper multiple times with the
            same set of commands. <code>combine-files</code> and <code>merge-files</code> change this behavior.</p>
        <p><strong>Options</strong></p>
        <p><code>&lt;files&gt;</code> or <code>files=</code> File(s) to input (space-separated list). Use <code>-</code>
            to import TopoJSON or GeoJSON from <code>/dev/stdin</code>. Literal JSON data can also be used instead of a
            file name.</p>
        <p><code>combine-files</code> Import multiple files to separate layers with shared topology. Useful for
            generating a single TopoJSON file containing multiple geometry objects.</p>
        <p><code>merge-files</code> (Deprecated) Merge features from multiple input files into as few layers as
            possible. Preferred method: import files to separate layers using <code>-i combine-files</code>, then use
            the <code>-merge-layers</code> command to merge layers. </p>
        <p><code>snap</code> Snap together vertices within a small distance threshold. This option is intended to fix
            minor coordinate misalignments in adjacent polygons. The snapping distance is 0.0025 of the average segment
            length.</p>
        <p><code>snap-interval=</code> Specify snapping distance in source units.</p>
        <p><code>precision=</code> (Deprecated) Round all coordinates to a specified precision, e.g. <code>0.001</code>.
            It is recommended to set coordinate precision on export, using <code>-o precision=</code>.</p>
        <p><code>no-topology</code> Skip topology identification to speed up processing of large files. For use with
            commands like <code>-filter</code> that don&#39;t require topology.</p>
        <p><code>encoding=</code> Specify encoding used for reading .dbf files and delimited text files. If the
            <code>encoding</code> option is missing, mapshaper will try to detect the encoding of .dbf files. Dbf
            encoding can also be set using a .cpg file.</p>
        <p><code>id-field=</code> (Topo/GeoJSON) Import values of &quot;id&quot; property to this data field.</p>
        <p><code>string-fields=</code> (CSV) List of fields to import as strings (e.g. FIPS,ZIPCODE). Using
            <code>string-fields=*</code> imports all fields as strings.</p>
        <p><code>field-types=</code> Type hints for importing delimited text. Takes a comma-separated list of field
            names with type hints appended; e.g. <code>FIPS:str,zipcode:str</code>. Recognized type hints include
            <code>:str</code> or <code>:string</code>, <code>:num</code> or <code>:number</code>. Without a type hint,
            fields containing text data that looks like numeric data, like ZIP Codes, will be converted to numbers.</p>
        <p><code>csv-skip-lines=</code> Number of lines to skip at the beginning of a CSV file. Useful when a CSV has
            been exported from a spreadsheet and there are rows of notes above the data section of the worksheet.</p>
        <p><code>csv-lines=</code> Number of data records to import from a CSV file (default is all).</p>
        <p><code>csv-field-names=</code> Comma-sep. list of names to assign each field. Can be used in conjunction with
            <code>csv-skip-lines=1</code> to replace names from an existing set of field headers.</p>
        <p><code>csv-fields=</code> Comma-sep. list of fields to import from a CSV-formatted input file. Fields are
            filtered as the file is read, which reduces the memory needed to import very large CSV files.</p>
        <p><code>decimal-comma</code> Import numbers formatted with decimal commas, not decimal points. Accepted
            formats: <code>1.000,01</code> <code>1 000,01</code> (both imported as as 1000.01).</p>
        <p><code>csv-dedup-fields</code> Assign unique names to CSV fields with duplicate names.</p>
        <p><code>csv-filter=</code> A JavaScript expression for importing a subset of the records in a CSV file. Records
            are filtered as the file is read, which reduces the memory needed to import very large CSV files.</p>
        <p><code>json-path=</code> [JSON] Path to an array of data records or a GeoJSON object. For example,
            <code>json-path=data/counties</code> expects a JSON object with the following structure
            <code>{&quot;data&quot;: {&quot;counties&quot;: []}}</code>.</p>
        <p><code>name=</code> Rename the imported layer (or layers).</p>
        <p><strong>Example</strong> </p>
        <pre><code class="lang-bash"># Input a Shapefile <span class="hljs-keyword">with</span> <span class="hljs-keyword">text</span> <span class="hljs-keyword">data</span> <span class="hljs-built_in">in</span> the latin1 encoding <span class="hljs-built_in">and</span> see what kind of <span class="hljs-keyword">data</span> it <span class="hljs-built_in">contains</span>
        mapshaper countries_wgs84.shp encoding=latin1 -info
        </code></pre>
        <h3 id="-o-output-">-o (output)</h3>
        <p>Save content of the target layer(s) to a file or files.</p>
        <p><strong>Options</strong></p>
        <p><code>&lt;file&gt;|&lt;directory&gt;|-</code> Name of output file or directory. Use <code>-</code> to export
            text-based formats to <code>/dev/stdout</code>.</p>
        <p><code>format=shapefile|geojson|topojson|json|dbf|csv|tsv|svg</code> Specify output format. If the
            <code>format=</code> option is missing, Mapshaper tries to infer the format from the output filename. If no
            filename is given, Mapshaper uses the input format. The <code>json</code> format is an array of objects
            containing data properties for each feature.</p>
        <p><code>target=</code> Specify layer(s) to export (comma-separated list). The default target is the output
            layer(s) of the previous command. Use <code>target=*</code> to select all layers.</p>
        <p><code>force</code> Allow output files to overwrite input files (without this option, overwriting input files
            is not allowed).</p>
        <p><code>gzip</code> Apply gzip compression to output files.</p>
        <p><code>zip</code> Save output files in a single .zip archive.</p>
        <p><code>cut-table</code> Detach attribute data from shapes and save as a JSON file.</p>
        <p><code>drop-table</code> Remove attribute data from output.</p>
        <p><code>precision=</code> Round all coordinates to a specified precision, e.g. <code>precision=0.001</code>.
            Useful for reducing the size of GeoJSON files.</p>
        <p><code>bbox-index</code> Export a JSON file containing bounding boxes of each output layer.</p>
        <p><code>encoding=</code> (Shapefile/CSV) Encoding of input text (by default, Shapefile encoding is
            auto-detected and CSV files are assumed to be UTF-8).</p>
        <p><code>field-order=</code> (Shapefile/CSV) <code>field-order=ascending</code> sorts data fields in
            alphabetical order of field names (A-Z, case-insensitive).</p>
        <p><code>id-field=</code> (Topo/GeoJSON/SVG) Specify one or more data fields to use as the &quot;id&quot;
            property of GeoJSON, TopoJSON or SVG features (comma-separated list). When exporting multiple layers, you
            can pass a list of field names. The first listed name that is present in a layer&#39;s attribute table will
            be used as the id field for that layer.</p>
        <p><code>bbox</code> (Topo/GeoJSON) Add bbox property to the top-level object.</p>
        <p><code>extension=</code> (Topo/GeoJSON) set file extension (default is &quot;.json&quot;).</p>
        <p><code>prettify</code> (Topo/GeoJSON) Format output for readability.</p>
        <p><code>singles</code> (TopoJSON) Save each output layer as a separate file. Each output file and the TopoJSON
            object that it contains are named after the corresponding data layer. </p>
        <p><code>quantization=</code> (TopoJSON) Specify quantization as the maximum number of differentiable points
            along either dimension. Equivalent to the quantization parameter used by the <a
                href="https://github.com/topojson/topojson-client#topoquantize">topoquantize</a> command line program.
            By default, mapshaper applies quantization equivalent to 0.02 of the average segment length.</p>
        <p><code>no-quantization</code> (TopoJSON) Arc coordinates are encoded at full precision and without
            delta-encoding.</p>
        <p><code>presimplify</code> (TopoJSON) Add a threshold value to each arc vertex in the z position (i.e. [x, y,
            z]). Useful for dynamically simplifying paths using vertex filtering. Given W as the width of the map
            viewport in pixels, S as the ratio of content width to viewport width, and pz as the presimplify value of a
            point, the following expression tests if the point should be excluded from the output path:
            <code>pz &gt; 0 &amp;&amp; pz &lt; 10000 / (W * S)</code>.</p>
        <p><code>topojson-precision=</code> (TopoJSON) Set quantization as a fraction of the average segment length.</p>
        <p><code>ndjson</code> (GeoJSON/JSON) Output newline-delimited records.</p>
        <p><code>gj2008</code> (GeoJSON) Generate output that is consistent with the pre-RFC 7946 GeoJSON spec (dating
            to 2008). Polygon rings are CW and holes are CCW, which is the opposite of the default RFC 7946-compatible
            output. Mapshaper&#39;s default GeoJSON output is now compatible with the current specification (RFC 7946).
        </p>
        <p><code>combine-layers</code> (GeoJSON) Combine multiple output layers into a single GeoJSON file.</p>
        <p><code>geojson-type=</code> (GeoJSON) Overrides the default output type. Possible values:
            &quot;FeatureCollection&quot;, &quot;GeometryCollection&quot;, &quot;Feature&quot; (for a single feature).
        </p>
        <p><code>hoist=</code> (GeoJSON) Move one or more properties to the root level of each Feature. Hoisting a field
            named &quot;id&quot; creates an id for each Feature. This option can also be used to create non-standard
            Feature attributes (as used by the tippecanoe program).</p>
        <p><code>width=</code> (SVG/TopoJSON) Set the width of the output dataset in pixels. When used with TopoJSON
            output, this option switches the output coordinates from geographic units to pixels and flips the Y axis.
            SVG output is always in pixels (default SVG width is 800).</p>
        <p><code>height=</code> (SVG/TopoJSON) Similar to the <code>width</code> option. If both <code>height</code> and
            <code>width</code> are set, content is centered inside the <code>[0, 0, width, height]</code> bounding box.
        </p>
        <p><code>max-height=</code> (SVG/TopoJSON) Limit output height (units: pixels).</p>
        <p><code>margin=</code> (SVG/TopoJSON) Set the margin between coordinate data and the edge of the viewport
            (default is 1). To assign different margins to each side, pass a list of values in the order
            <code>&lt;left,bottom,right,top&gt;</code> (similar to the <code>bbox=</code> option found in other
            commands).</p>
        <p><code>pixels=</code> (SVG/TopoJSON) Output area in pixels (alternative to width=).</p>
        <p><code>id-prefix=</code> Prefix for namespacing layer and feature ids.</p>
        <p><code>svg-data=</code> (SVG) Export a comma-seperated list of data fields as SVG data-<em> attributes.
                Attribute names should match the following regex pattern: `/^[a-z<em>][a-z0-9</em>-]</em>$/`.
            Non-conforming fields are skipped.</p>
        <p><code>svg-scale=</code> (SVG) Scale SVG output using geographical units per pixel (an alternative to the
            <code>width=</code> option).</p>
        <p><code>svg-bbox=&lt;xmin,ymin,xmax,ymax&gt;</code> (SVG) Bounding box of SVG map in projected map units. By
            default, the extent of SVG output fits the content; this option lets you provide a custom extent. This could
            be useful when aligning the SVG output with other content layers, such as images or videos.</p>
        <p><code>point-symbol=square</code> (SVG) Use squares instead of circles to symbolize point data.</p>
        <p><code>delimiter=</code> (CSV) Set the field delimiter for CSV/delimited text output; e.g.
            <code>delimiter=|</code>.</p>
        <p><code>decimal-comma</code> (CSV) Export numbers with decimal commas instead of decimal points (common in
            Europe and elsewhere).</p>
        <p><strong>Example</strong></p>
        <pre><code class="lang-bash"><span class="hljs-comment"># Convert all the Shapefiles in one directory into GeoJSON files in a different directory.</span>
        <span class="hljs-attribute">mapshaper</span> shapefiles/<span class="hljs-regexp">*.shp</span> -o geojson/ format=geojson
        </code></pre>
        <h2 id="editing-commands">Editing Commands</h2>
        <h3 id="-affine">-affine</h3>
        <p>Transform coordinates by shifting, scaling and rotating. Not recommended for unprojected datasets.</p>
        <p><code>shift=</code> X,Y shift in source units (e.g. 5000,-5000)</p>
        <p><code>scale=</code> Scale (default is 1)</p>
        <p><code>rotate=</code> Angle of rotation in degrees (default is 0)</p>
        <p><code>anchor=</code> Center of rotation/scaling (default is center of the bounding box of the selected
            content)</p>
        <p><code>where=</code> Use a JS expression to select a subset of features.</p>
        <p>Common options: <code>target=</code></p>
        <h3 id="-classify">-classify</h3>
        <p>Assign colors or data values to each feature using one of several classification methods. Methods for
            sequential data include <code>quantile</code>, <code>equal-interval</code>, <code>hybrid</code> and
            <code>nice</code> or categorical classification to a data field.</p>
        <p><code>&lt;field&gt;</code> or <code>field=</code> Name of the data field to classify.</p>
        <p><code>save-as=</code> Name of a (new or existing) field to receive the output of classification. The default
            output field for colors is <code>fill</code> or <code>stroke</code> (depending on geometry type) and
            <code>class</code> for non-color output.</p>
        <p><code>values=</code> List of values to assign to data classes. If the number of values differs from the
            number of classes given by the (optional) <code>classes</code> or <code>breaks</code> option, then
            interpolated values will be calculated. Mapshaper uses d3 for interpolation.</p>
        <p><code>colors=</code> Takes a list of CSS colors, the name of a predefined color scheme, or
            <code>random</code>. Run the <a href="#-colors">-colors</a> command to list all of the built-in color
            schemes. Similar to the <code>values=</code> option, if the number of listed colors is different from the
            number of requested classes, interpolated colors are calculated.</p>
        <p><code>non-adjacent</code> Assign colors to a polygon layer in a randomish pattern, trying not to assign the
            same color to adjacent polygons. Mapshaper&#39;s algorithm balances performance and quality. Usually it can
            find a solution with four or five colors. If mapshaper is unable to avoid giving the same color to
            neighboring polygons, it will print a warning. You can resolve the problem by increasing the number of
            colors.</p>
        <p><code>stops=</code> A pair of comma-separated numbers (0-100) for limiting the output range of a color ramp.
        </p>
        <p><code>null-value=</code> Value (or color) to use for invalid or missing data.</p>
        <p><code>classes=</code> Number of data classes. This number can also be inferred from the <code>breaks=</code>
            or <code>values=</code> options.</p>
        <p><code>breaks=</code> Specify user-defined sequential class breaks (an alternative to automatic classification
            using <code>quantile</code>, <code>equal-interval</code>, etc.).</p>
        <p><code>outer-breaks=</code> A pair of comma-separated numbers setting min and max breakpoints to use when
            computing class breaks. This setting overrides the default behavior, which is to use the min and max values
            of the data field being classified. This setting can be used to prevent extreme data values (outliers) from
            affecting equal-interval classification. Also useful for setting outside breakpoints for continuous color
            ramps (when using the <code>continuous</code> option).</p>
        <p><code>method=</code> Classification method. One of: <code>quantile</code>, <code>equal-interval</code>,
            <code>nice</code>, <code>hybrid</code> (sequential data), <code>categorical</code>,
            <code>non-adjacent</code> and <code>indexed</code>. This parameter is not required if the classification
            method can be inferred from other options. For example, the <code>index-field=</code> parameter implies
            indexed classification, the <code>categories=</code> parameter implies categorical classification.</p>
        <p><code>quantile</code> Use quantile classification. Shortcut for <code>method=quantile</code>.</p>
        <p><code>equal-interval</code> Use equal interval classification. Shortcut for
            <code>method=equal-interval</code>.</p>
        <p><code>nice</code> Same as <code>method=nice</code>. This scheme finds equally spaced, round breakpoints that
            roughly divide the dataset into equal parts (similar to quantile classification).</p>
        <p><code>invert</code> Reverse the order of colors/values.</p>
        <p><code>continuous</code> Output continuously interpolated values (experimental). Uses linear interpolation
            between class breaks, which may give poor results with some distributions of data. This option is for
            creating unclassed/continuous-color maps.</p>
        <p><code>index-field=</code> Use class ids that have been precalculated and assigned to this field. Values
            should be integers from <code>0 ... n-1</code> (where n is the number of classes). <code>-1</code> is the
            null value.</p>
        <p><code>precision=</code> Round data values before classification (e.g. <code>precision=0.1</code>).</p>
        <p><code>categories=</code> List of values in the source data field. Using this option triggers categorical
            classification.</p>
        <p><code>other=</code> Default value for categorical classification. This value is used when the value of the
            source data field is not present in the list of values given by <code>categories=</code>. Defaults to
            <code>null-value=</code> or null.</p>
        <p><strong>Options for generating SVG keys</strong></p>
        <p><code>key-style=</code> One of: simple, gradient, dataviz</p>
        <p><code>key-name=</code> Name of output SVG file</p>
        <p><code>key-width=</code> Width of key in pixels</p>
        <p><code>key-font-size=</code> Font size of tic labels in pixels</p>
        <p><code>key-tile-height=</code> Height of color tiles in pixels</p>
        <p><code>key-tic-length=</code> Length of tic mark in pixels</p>
        <p><code>key-label-suffix=</code> String to append to each label</p>
        <p><code>key-last-suffix=</code> String to append to the last label</p>
        <p><strong>Examples</strong></p>
        <pre><code class="lang-bash"><span class="hljs-comment"># Apply a sequential color ramp to a polygon dataset using quantiles.</span>
        mapshaper covid_cases.geojson -classify <span class="hljs-attr">save-as=fill</span> quantile <span class="hljs-attr">color-scheme=Oranges</span> <span class="hljs-attr">classes=6</span> -o out.geojson
        </code></pre>
        <h3 id="-clean">-clean</h3>
        <p>This command attempts to repair various kinds of abnormal geometry that might cause problems when running
            other mapshaper commands or when using other software.</p>
        <p>Features with null geometries are deleted, unless the <code>allow-empty</code> flag is used.</p>
        <p>Polygon features are cleaned by removing overlaps and filling small gaps between adjacent polygons. Only gaps
            that are completely enclosed can be filled. Areas that are contained by more than one polygon (overlaps) are
            assigned to the polygon with the largest area. Similarly, gaps are assigned to the largest-area polygon.
            This rule may give undesired results and will likely change in the future.</p>
        <p>Line features are cleaned by removing self-intersections within the same path. Self-intersecting paths are
            split at the point of intersection and converted into multiple paths within the same feature. When two
            separate paths intersect in-between segment endpoints, new vertices are inserted at the point of
            intersection.</p>
        <p>Point features are cleaned by removing duplicate coordinates within the same feature.</p>
        <p><code>gap-fill-area=</code> (polygons) Gaps smaller than this area will be filled; larger gaps will be
            retained as holes in the polygon mosaic. Example values: 2km2 500m2 0. Defaults to a dynamic value
            calculated from the geometry of the dataset.</p>
        <p><code>sliver-control=</code> (polygons) Preferentially remove slivers (polygons with a high perimeter-area
            ratio). Accepts values from 0-1, default is 1. Implementation: multiplies the area of gap areas by the
            &quot;Polsby Popper&quot; compactness metric before applying area threshold.</p>
        <p><code>overlap-rule=</code> (polygons) Assign overlapping polygon areas to one of the overlapping features
            based on this rule. Possible options are: min-id, max-id, min-area, max-area (default is max-area).</p>
        <p><code>allow-overlaps</code> Allow features to overlap each other. The default behavior is to remove overlaps.
        </p>
        <p><code>snap-interval=</code> Snap vertices within a given threshold before performing other kinds of geometry
            repair. Defaults to a very small threshold. Uses source units.</p>
        <p><code>rewind</code> Fix errors in the winding order of polygon rings.</p>
        <p><code>allow-empty</code> Allow null geometries, which are removed by default.</p>
        <p>Common options: <code>target=</code></p>
        <h3 id="-clip">-clip</h3>
        <p>Remove features or portions of features that fall outside a clipping area.</p>
        <p><code>&lt;source&gt;</code> or <code>source=</code> Clip to a set of polygon features. Takes the filename or
            layer id of the clip polygons.</p>
        <p><code>bbox=&lt;xmin,ymin,xmax,ymax&gt;</code> Delete features or portions of features that fall outside a
            bounding box.</p>
        <p><code>bbox2=</code> Faster bounding box clipping than <code>bbox=</code> (experimental).</p>
        <p><code>remove-slivers</code> Remove tiny sliver polygons created by clipping.</p>
        <p>Common options: <a href="#common-options"><code>name=</code> <code>+</code> <code>target=</code></a></p>
        <pre><code class="lang-bash"><span class="hljs-comment"># Example: Clip a polygon layer using another polygon layer.</span>
        mapshaper usa_counties.<span class="hljs-keyword">shp </span>-clip land-area.<span class="hljs-keyword">shp </span>-o clipped.<span class="hljs-keyword">shp</span>
        </code></pre>
        <h3 id="-colorizer">-colorizer</h3>
        <p>Define a function for converting data values to colors that can be used in subsequent calls to the
            <code>-style</code> command.</p>
        <p><code>name=</code> Name of the colorizer function.</p>
        <p><code>colors=</code> List of CSS colors.</p>
        <p><code>random</code> Randomly assign colors. Uses <code>colors=</code> list if given.</p>
        <p><code>breaks=</code> Ascending-order list of breaks (thresholds) for creating a sequential color scheme.</p>
        <p><code>categories=</code> List of data values (keys) for creating a categorical color scheme.</p>
        <p><code>other=</code> Default color for categorical scheme (defaults to <code>nodata</code> color).</p>
        <p><code>nodata=</code> Color to use for invalid or missing data (default is white).</p>
        <p><code>precision=</code> Rounding precision to apply to numerical data before converting to a color (e.g.
            0.1).</p>
        <pre><code class="lang-bash"><span class="hljs-comment"># Example: define a function for a sequential color scheme and assign colors based on data values</span>
        mapshaper data.json <span class="hljs-string">\</span>
            -colorizer name=getColor colors=<span class="hljs-string">'#f0f9e8,#bae4bc,#7bccc4,#2b8cbe'</span> breaks=<span class="hljs-number">25</span>,<span class="hljs-number">50</span>,<span class="hljs-number">75</span> <span class="hljs-string">\</span>
            -each <span class="hljs-string">'color = getColor(PCT)'</span> <span class="hljs-string">\</span>
            -o output.json
        
        <span class="hljs-comment"># Example: define a function for a categorical color scheme and use it to assign fill colors</span>
        mapshaper data.json <span class="hljs-string">\</span>
            -colorizer name=calcFill colors=<span class="hljs-string">'red,blue,green'</span> categories=<span class="hljs-string">'Republican,Democrat,Other'</span> <span class="hljs-string">\</span>
            -style fill=<span class="hljs-string">'calcFill(PARTY)'</span> <span class="hljs-string">\</span>
            -o output.svg
        </code></pre>
        <h3 id="-dashlines">-dashlines</h3>
        <p>Split lines into sections, with or without a gap.</p>
        <p><code>dash-length=</code> Length of split-apart lines (e.g. 200km)
            <code>gap-length=</code> Length of gaps between dashes (default is 0)
            <code>scaled</code> Scale dashes and gaps to prevent partial dashes
            <code>planar</code> Use planar geometry
            <code>where=</code> Use a JS expression to select a subset of features.
        </p>
        <h3 id="-dissolve">-dissolve</h3>
        <p>Aggregate groups of features using a data field, or aggregate all features if no field is given. For polygon
            layers, <code>-dissolve</code> merges adjacent polygons by erasing shared boundaries. For point layers,
            <code>-dissolve</code> replaces a group of points with their centroid. For polyline layers,
            <code>-dissolve</code> tries to merge contiguous polylines into as few polylines as possible.</p>
        <p><code>&lt;fields&gt;</code> or <code>fields=</code> (optional) Name of a data field or fields to dissolve on.
            Accepts a comma-separated list of field names.</p>
        <p><code>group-points</code> [points] Group the points from each dissolved group of features into a multi-point
            feature instead of converting multiple points into a single-point centroid feature.</p>
        <p><code>weight=</code> [points] Name of a field or a JS expression for generating weighted centroids. For
            example, the following command estimates the &quot;center of mass&quot; of the U.S. population:
            <code>mapshaper census_tracts.shp -points -dissolve weight=POPULATION -o out.shp</code></p>
        <p><code>planar</code> [points] Treat decimal degree coordinates as planar cartesian coordinates when
            calculating dissolve centroids. (By default, mapshaper calculates the centroids of lat-long point data in 3D
            space.)</p>
        <p><code>calc=</code> Use built-in JavaScript functions to create data fields in the dissolved layer. See
            example below; see <a href="#-calc">-calc</a> for a list of supported functions.</p>
        <p><code>sum-fields=</code> Fields to sum when dissolving (comma-sep. list).</p>
        <p><code>copy-fields=</code> Fields to copy when dissolving (comma-sep. list). Copies values from the first
            feature in each group of dissolved features.</p>
        <p><code>multipart</code> Group features from the target layer into multipart features, without otherwise
            modifying geometry.</p>
        <p><code>where=</code> Use a JS expression to select a subset of features to dissolve.</p>
        <p>Common options: <code>name=</code> <code>+</code> <code>target=</code></p>
        <pre><code class="lang-bash"><span class="hljs-comment"># Example: Aggregate county polygons to states</span>
        mapshaper counties.<span class="hljs-keyword">shp </span>-<span class="hljs-keyword">dissolve </span>STATE -o states.<span class="hljs-keyword">shp
        </span>
        <span class="hljs-comment"># Example: Use the calc= option to count the number of dissolved features and perform other calculations</span>
        mapshaper counties.<span class="hljs-keyword">shp </span>-<span class="hljs-keyword">dissolve </span>STATE calc=<span class="hljs-string">'n = count(), total_pop = sum(POP), max_pop = max(POP), min_pop = min(POP)'</span>
        </code></pre>
        <h3 id="-dissolve2">-dissolve2</h3>
        <p>Similar to <code>-dissolve</code>, but able to handle polygon datasets containing overlaps and gaps between
            adjacent polygons.</p>
        <p><code>gap-fill-area=</code> (polygons) Gaps smaller than this area will be filled; larger gaps will be
            retained as holes in the polygon mosaic. Example values: 2km2 500m2 0. Defaults to a dynamic value
            calculated from the geometry of the dataset.</p>
        <p><code>sliver-control=</code> (polygons) Preferentially remove slivers (polygons with a high perimeter-area
            ratio). Accepts values from 0-1, default is 1. Implementation: multiplies the area of gap areas by the
            &quot;Polsby Popper&quot; compactness metric before applying area threshold.</p>
        <p><code>allow-overlaps</code> Allow dissolved groups of features to overlap each other. The default behavior is
            to remove overlaps.</p>
        <p>Other options: <code>&lt;fields&gt;</code> <code>calc=</code> <code>sum-fields=</code>
            <code>copy-fields=</code> <code>name=</code> <code>+</code> <code>target=</code></p>
        <h3 id="-divide">-divide</h3>
        <p>Divide a polyline layer by a polygon layer. Line features that cross polygon boundaries are divided into
            separate features. Data fields from the polygon layer are copied to the line layer, as in the
            <code>-join</code> command.</p>
        <p><code>&lt;file|layer&gt;</code> or <code>source=</code> File or layer containing polygon features.</p>
        <p><code>fields=</code> A comma-separated list of fields to copy from the polygon layer (see <code>-join</code>
            command).</p>
        <p><code>calc=</code> Use JS assignments and built-in functions to convert values from the polygon layer to
            (new) fields the target table (see <code>-join</code> command).</p>
        <p>Other options: <code>target=</code></p>
        <h3 id="-dots">-dots</h3>
        <p>Fill polygons with random points, for making dot density maps. This command should be applied to projected
            layers.</p>
        <p><code>&lt;fields&gt;</code> or <code>fields=</code> List of one or more data fields containing data for the
            number of dots to place in each polygon.</p>
        <p><code>colors=</code> List of dot colors (one color for each field in the <code>fields=</code> parameter).
            Dots of different colors are placed in random sequence, so dots of one color do not consistently cover up
            dots of other colors in the densest areas.</p>
        <p><code>values=</code> List of values to assign to dots (alternative to <code>colors=</code>).</p>
        <p><code>save-as=</code> Name of a (new or existing) field to receive the assigned colors or values. (By
            default, colors are assigned to the <code>fill</code> field.)</p>
        <p><code>r=</code> Dot radius in pixels.</p>
        <p><code>evenness=</code> A value from 0-1. 0 corresponds to purely random placement, 1 maintains (fairly) even
            spacing between the dots within each polygon. The default is 1.</p>
        <p><code>per-dot=</code> A number for scaling data values. For example, use <code>per-dot=100</code> to make a
            map that displays one dot per 100 people (or whatever entity is being visualized).</p>
        <p><code>copy-fields=</code> List of fields to copy from the original polygon layer to each dot feature.</p>
        <p><code>multipart</code> Combine groups of same-color dots into multi-part features.</p>
        <p>Other options: <code>name=</code> <code>+</code> <code>target=</code></p>
        <h3 id="-drop">-drop</h3>
        <p>Delete the target layer(s) or elements within the target layer(s).</p>
        <p><code>fields=</code> Delete a (comma-separated) list of attribute data fields. To delete all fields, use
            <code>fields=*</code>.</p>
        <p><code>geometry</code> Delete all geometry.</p>
        <p><code>holes</code> Delete any holes from a polygon layer.</p>
        <p><code>target=</code> Layer(s) to target.</p>
        <h3 id="-each">-each</h3>
        <p>Apply a JavaScript expression to each feature in a layer. Data properties are available as local variables.
            Additional feature-level properties are available as read-only properties of the <code>this</code> object.
        </p>
        <p><strong>Tip:</strong> Enclose JS expressions in single quotes when using the bash shell (Mac and Linux) to
            avoid shell expansion of &quot;!&quot; and other special characters. Using the Windows command interpreter,
            enclose JS expressions in double quotes.</p>
        <p><code>&lt;expression&gt;</code> or <code>expression=</code> JavaScript expression to apply to each feature.
        </p>
        <p><code>where=</code> Secondary boolean JS expression for targetting a subset of features.</p>
        <p><code>target=</code> Layer to target.</p>
        <p><strong>Utility functions</strong>
            Several utility functions are available within expressions.</p>
        <ul>
            <li><code>format_dms(coord [, fmt])</code> Format a latitude or longitude coordinate as a DMS string
                (degrees, minutes, seconds). The optional second argument lets you specify a custom format. Example
                format strings:<ul>
                    <li><code>[+-]DDDMM.MMMMM</code></li>
                    <li><code>DdMmSs [EW]</code></li>
                    <li><code>DD° MM′ SS.SSSSS″ [NS]</code></li>
                    <li><code>[-]DD.DDDDD°</code></li>
                </ul>
            </li>
            <li><code>parse_dms(string [, fmt])</code> Parse a DMS string to a numerical coordinate. The optional second
                argument gives the format to use for parsing. Example (given DMS-formatted fields <code>latDMS</code>
                and <code>lonDMS</code>):
                <code>-each &#39;lat = parse_dms(latDMS, &quot;DDDMMSS.SSS[NS]&quot;), lon = parse_dms(lonDMS, &quot;DDDMMSS.SSS[EW]&quot;)&#39;</code>.
            </li>
            <li><code>round(number [, decimals])</code> Optional second argument gives the number of decimals to use.
            </li>
        </ul>
        <p><strong>Properties of <code>this</code></strong></p>
        <p>The <code>this</code> object, available within expressions, has properties relating to the geometry and
            attribute data of a feature.</p>
        <p><em>Properties are read-only unless otherwise indicated.</em></p>
        <p>All layer types</p>
        <ul>
            <li><code>this.id</code> Numerical id of the feature (0-based)</li>
            <li><code>this.layer_name</code> Name of the layer, or <code>&quot;&quot;</code> if layer is unnamed.</li>
            <li><code>this.properties</code> Data properties (also available as local variables) (read/write)</li>
            <li><code>this.layer</code> Object with &quot;name&quot; and &quot;data&quot; properties</li>
            <li><code>this.geojson</code> (getter) Returns each feature as a GeoJSON Feature object.</li>
            <li><code>this.geojson=</code> (setter) Update target layer with GeoJSON.</li>
        </ul>
        <p>Point layers</p>
        <ul>
            <li><code>this.coordinates</code> An array of [x, y] coordinates with one or more members, or null
                (read/write)</li>
            <li><code>this.x</code> X-coordinate of point, or <code>null</code> if geometry is empty. Refers to the
                first point of multi-point features. (read/write)</li>
            <li><code>this.y</code> Y-coordinate of point or <code>null</code>. (read/write)</li>
        </ul>
        <p>Polygon layers</p>
        <ul>
            <li><code>this.area</code> Area of polygon feature, after any simplification is applied. For lat-long
                datasets, returns area on a sphere in units of square meters.</li>
            <li><code>this.planarArea</code> Calculates the planar area of lat-long datasets, as though latitude and
                longitude were cartesian coordinates.</li>
            <li><code>this.originalArea</code> Area of polygon feature without simplification</li>
            <li><code>this.centroidX</code> X-coord of centroid</li>
            <li><code>this.centroidY</code> Y-coord of centroid</li>
            <li><code>this.innerX</code> X-coord of an interior point (for anchoring symbols or labels)</li>
            <li><code>this.innerY</code> Y-coord of an interior point</li>
            <li><code>this.perimeter</code> Perimeter of each feature. For lat-long datasets, returns length in meters.
            </li>
        </ul>
        <p>Polyline layers</p>
        <ul>
            <li><code>this.length</code> Length of each polyline feature. For lat-long datasets, returns length in
                meters.</li>
        </ul>
        <p>Polygon, polyline and point layers</p>
        <ul>
            <li><code>this.partCount</code> 1 for single-part features, &gt;1 for multi-part features, 0 for null
                features</li>
            <li><code>this.isNull</code> True if feature has null geometry</li>
            <li><code>this.bounds</code> Bounding box as array [xmin, ymin, xmax, ymax]</li>
            <li><code>this.width</code> Width of bounding box</li>
            <li><code>this.height</code> Height of bounding box</li>
        </ul>
        <p><strong>Note:</strong> Centroids are calculated for the largest ring of multi-part polygons, and do not
            account for holes.</p>
        <p><strong>Note:</strong> Most geometric properties are calculated using planar geometry. Exceptions are the
            areas of unprojected polygons and the lengths of unprojected polylines. These calculations use spherical,
            not ellipsoidal geometry, so are not as accurate as the equivalent calculations in a GIS application.</p>
        <p><strong>Examples</strong></p>
        <pre><code class="lang-bash"># <span class="hljs-keyword">Create</span> two fields
        mapshaper counties.shp -<span class="hljs-keyword">each</span> <span class="hljs-string">'STATE_FIPS=COUNTY_FIPS.substr(0, 2), AREA=this.area'</span> -o <span class="hljs-keyword">out</span>.shp
        
        # Delete two fields
        mapshaper states.shp -<span class="hljs-keyword">each</span> <span class="hljs-string">'delete STATE_NAME, delete GEOID'</span> -o <span class="hljs-keyword">out</span>.shp
        
        # Rename a field
        mapshaper states.shp -<span class="hljs-keyword">each</span> <span class="hljs-string">'STATE_NAME=NAME, delete NAME'</span> -o <span class="hljs-keyword">out</span>.shp
        
        # Print the value <span class="hljs-keyword">of</span> a field <span class="hljs-keyword">to</span> the console
        mapshaper states.shp -<span class="hljs-keyword">each</span> <span class="hljs-string">'console.log(NAME)'</span>
        
        # Assign a <span class="hljs-keyword">new</span> data <span class="hljs-keyword">record</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">each</span> feature
        mapshaper states.shp -<span class="hljs-keyword">each</span> <span class="hljs-string">'this.properties = {FID: this.id}'</span> -o <span class="hljs-keyword">out</span>.shp
        </code></pre>
        <h3 id="-erase">-erase</h3>
        <p>Remove features or portions of features that fall inside an area.</p>
        <p><code>&lt;source&gt;</code> or <code>source=</code> File or layer containing erase polygons. Takes the
            filename or layer id of the erase polygons.</p>
        <p><code>bbox=&lt;xmin,ymin,xmax,ymax&gt;</code> Delete features or portions of features that fall inside a
            bounding box. Similar to <code>-clip bbox=</code>.</p>
        <p><code>bbox2=</code> Faster bounding box erasing than <code>bbox=</code> (experimental).</p>
        <p><code>remove-slivers</code> Remove tiny sliver polygons created by erasing.</p>
        <p>Common options: <a href="#common-options"><code>name=</code> <code>+</code> <code>target=</code></a></p>
        <pre><code class="lang-bash"><span class="hljs-comment"># Example: Erase a polygon layer using another polygon layer.</span>
        mapshaper usa_counties.<span class="hljs-keyword">shp </span>-erase lakes.<span class="hljs-keyword">shp </span>-o out.<span class="hljs-keyword">shp</span>
        </code></pre>
        <h3 id="-explode">-explode</h3>
        <p>Divide each multi-part feature into several single-part features.</p>
        <p>Common options: <code>target=</code></p>
        <h3 id="-filter">-filter</h3>
        <p>Apply a boolean JavaScript expression to each feature, removing features that evaluate to false.</p>
        <p><code>&lt;expression&gt;</code> or <code>expression=</code> JS expression evaluating to <code>true</code> or
            <code>false</code>. Uses the same execution context as <a href="#-each"><code>-each</code></a>.</p>
        <p><code>bbox=</code> Retains features that intersect the given bounding box (xmin,ymin,xmax,ymax).</p>
        <p><code>invert</code> Invert the filter -- retain only those features that would have been deleted.</p>
        <p><code>remove-empty</code> Delete features with null geometry. May be used by itself or in combination with an
            <code>&lt;expression&gt;</code>.</p>
        <p>Common options: <a href="#common-options"><code>name=</code> <code>+</code> <code>target=</code> </a></p>
        <pre><code class="lang-bash"># Example: <span class="hljs-keyword">Select</span> counties <span class="hljs-keyword">from</span> <span class="hljs-keyword">New</span> England states
        mapshaper usa_counties.shp -filter <span class="hljs-string">'"ME,VT,NH,MA,CT,RI".indexOf(STATE) &gt; -1'</span> -o ne_counties.shp
        </code></pre>
        <h3 id="-filter-fields">-filter-fields</h3>
        <p>Delete fields in an attribute table, by listing the fields to retain. If no files are given, then all
            attributes are removed.</p>
        <p><code>&lt;fields&gt;</code> or <code>fields=</code> Comma-separated list of data fields to retain.</p>
        <p><code>invert</code> Invert the filter -- delete the listed fields instead of retaining them.</p>
        <p>Common options: <code>target=</code></p>
        <pre><code class="lang-bash"><span class="hljs-meta"># Example: Retain two fields</span>
        mapshaper states.shp -filter-fields FID,NAME -o <span class="hljs-keyword">out</span>.shp
        </code></pre>
        <h3 id="-filter-islands">-filter-islands</h3>
        <p>Remove small detached polygon rings (islands).</p>
        <p><code>min-area=</code> Remove small-area islands using an area threshold (e.g. 10km2).</p>
        <p><code>min-vertices=</code> Remove low-vertex-count islands.</p>
        <p><code>remove-empty</code> Delete features with null geometry.</p>
        <p><a href="#common-options"><code>target=</code></a></p>
        <h3 id="-filter-slivers">-filter-slivers</h3>
        <p>Remove small polygon rings.</p>
        <p><code>min-area=</code> Area threshold for removal (e.g. 10km2).</p>
        <p><code>sliver-control=</code> (polygons) Preferentially remove slivers (polygons with a high perimeter-area
            ratio). Accepts values from 0-1, default is 1. Implementation: multiplies the area of polygon rings by the
            &quot;Polsby Popper&quot; compactness metric before applying area threshold.</p>
        <p><code>remove-empty</code> Delete features with null geometry.</p>
        <p><a href="#common-options"><code>target=</code></a></p>
        <h3 id="-graticule">-graticule</h3>
        <p>Create a graticule layer appropriate for a world map centered on longitude 0.</p>
        <p><code>polygon</code> Create an polygon enclosing the entire area of the graticule. Useful for creating
            background or outline shapes for clipped projections, like Robinson or Stereographic.</p>
        <p><code>interval=</code> Specify the spacing of graticule lines (in degrees). Options include: 5, 10, 15, 30,
            45. Default is 10.</p>
        <h3 id="-grid">-grid</h3>
        <p>Create a continuous grid of square or hexagonal polygons.</p>
        <p>The <code>-grid</code> command should have a projected layer as its target. The cells of the grid will
            completely enclose the bounding box of the target layer.</p>
        <p>This command is intended for visualizing data in a grid. Typically, you would use the <code>-join</code>
            command to join data from a polygon or point layer to a grid layer. Use
            <code>-join interpolate=&lt;fields&gt;</code> to interpolate data values (typically count data) from the
            polygon layer to the grid layer based on area. Use
            <code>-join calc=&#39;&lt;field&gt; = sum(&lt;field&gt;)&#39;</code> or
            <code>-join calc=&#39;&lt;field&gt; = count()&#39;</code> to aggregate point data values.</p>
        <p><code>type=</code> Supported values: <code>square</code> <code>hex</code> <code>hex2</code>. The
            <code>hex</code> and <code>hex2</code> types have different rotations.</p>
        <p><code>interval=</code> The length of one side of a grid cell. Example values: <code>500m</code>
            <code>2km</code>.</p>
        <p>Other options: <code>name=</code> <code>+</code> <code>target=</code></p>
        <h3 id="-include">-include</h3>
        <p><code>&lt;file&gt;</code> or <code>file=</code> Path to the external .js file to load. The file should
            contain a single JS object. The properties of this object are converted to variables in the JS expression
            used by the <code>-each</code> command.</p>
        <h3 id="-inlay">-inlay</h3>
        <p>Inscribe a polygon layer within another polygon layer.</p>
        <p><code>&lt;source&gt;</code> or <code>source=</code> File or layer containing polygons to inlay</p>
        <p>Other options: <code>target=</code></p>
        <h3 id="-innerlines">-innerlines</h3>
        <p>Create a polyline layer consisting of shared boundaries with no attribute data.</p>
        <p><code>where=</code> Filter lines using a JS expression (see the <code>-lines where=</code> option).</p>
        <p>Other options: <code>name=</code> <code>+</code> <code>target=</code></p>
        <pre><code class="lang-bash"># <span class="hljs-keyword">Example</span>: <span class="hljs-keyword">Extract</span> the boundary between two states.
        mapshaper states.shp -filter 'STATE==<span class="hljs-string">"OR"</span> |<span class="hljs-type">| STATE</span>==<span class="hljs-string">"WA"</span>' -innerlines -o out.shp
        </code></pre>
        <h3 id="-join">-join</h3>
        <p>Join attribute data from a source layer or file to a target layer. If the <code>keys=</code> option is used,
            Mapshaper will join records by matching the values of key fields. If the <code>keys=</code> option is
            missing, Mapshaper will perform a polygon-to-polygon, point-to-polygon, polygon-to-point or point-to-point
            spatial join.</p>
        <p><code>&lt;file|layer&gt;</code> or <code>source=</code> File or layer containing data records to join.</p>
        <p><code>keys=</code> Names of two fields to use as join keys, separated by a comma. The key field from the
            destination table is followed by the key field from the source table. If the <code>keys=</code> option is
            missing, mapshaper performs a spatial join.</p>
        <p><code>calc=</code> Use JS assignments and built-in functions to convert values from the source table to (new)
            fields the target table. See the <a href="#-calc"><code>-calc</code> command reference</a> for a list of
            supported functions. Useful for handling many-to-one joins. See example below.</p>
        <p><code>where=</code> Use a boolean JS expression to filter records from the source table. The expression has
            the same syntax as the expression used by the <code>-filter</code> command. The functions
            <code>isMax(&lt;field&gt;)</code> <code>isMin(&lt;field&gt;)</code> and <code>isMode(&lt;field&gt;)</code>
            can be used in many-to-one joins to select among source records.</p>
        <p><code>fields=</code> A comma-separated list of fields to copy from the external table. If the
            <code>fields</code> option and <code>calc</code> options are both absent, all fields are copied except the
            key field (if joining on keys) unless the. Use <code>fields=*</code> to copy all fields, including any key
            field. Use <code>fields=</code> (empty list) to copy no fields.</p>
        <p><code>prefix=</code> Add a prefix to the names of fields joined from the external attribute table.</p>
        <p><code>interpolate=</code> (polygon-to-polygon joins only) A list of fields to interpolate/reaggregate based
            on area of overlap. Intended for fields containing count data, such as population counts or vote counts.
            Treats data as being uniformly distributed within polygon areas.</p>
        <p><code>point-method</code> (polygon-to-polygon joins only) Use an alternate method for joining two polygon
            layers. The default polygon-polygon join method detects areas of overlap between two polygon layers by
            compositing the two layers internally. This method is simpler -- it generates a temporary point layer from
            the source layer with the greater number of features (using the same inner-point method as the
            <code>-points inner</code> command), and then performs a point-to-polygon or polygon-to-point join. This
            method does not support the <code>interpolate=</code> option.</p>
        <p><code>largest-overlap</code> (polygon-to-polygon joins only) selects a single polygon to join when multiple
            source polygons overlap a target polygon, based on largest area of overlap.</p>
        <p><code>max-distance=</code> (point-to-point joins only) Join source layer points within this distance of a
            target layer point.</p>
        <p><code>duplication</code> Create duplicate features in the target layer on many-to-one joins.</p>
        <p><code>sum-fields=</code> (deprecated) A comma-separated list of fields to sum when several source records
            match the same target record. This option is equivalent to using the <code>sum()</code> function inside a
            <code>calc=</code> expression like this: <code>calc=&#39;FIELD = sum(FIELD)&#39;</code>.</p>
        <p><code>string-fields=</code> A comma-separated list of fields in source CSV file to import as strings (e.g.
            FIPS,ZIPCODE).</p>
        <p><code>field-types=</code> A comma-separated list of type hints (when joining a CSV file or other delimited
            text file). See <code>-i field-types=</code> above.</p>
        <p><code>force</code> Allow values in the target data table to be overwritten by values in the source table when
            both tables contain identically named fields.</p>
        <p><code>unjoined</code> Copy unjoined records from the source table to a layer named &quot;unjoined&quot;.</p>
        <p><code>unmatched</code> Copy unmatched records from the destination table to a layer named
            &quot;unmatched&quot;.</p>
        <p>Other options: <code>encoding=</code> <code>target=</code></p>
        <p><strong>Examples</strong></p>
        <p>Join a point layer to a polygon layer (spatial join), using the <code>calc=</code> option to handle
            many-to-one matches.</p>
        <pre><code class="lang-bash">mapshaper states.shp -join points.shp calc='median_score = <span class="hljs-keyword">median</span>(<span class="hljs-keyword">SCORE</span>), mean_score = average(<span class="hljs-keyword">SCORE</span>), join_count = <span class="hljs-keyword">count</span>()' -o <span class="hljs-keyword">out</span>.shp
        </code></pre>
        <p>Copy data from a csv file to the attribute table of a Shapefile by matching values from the
            <em>STATE_FIPS</em> field of the Shapefile and the <em>FIPS</em> field of the csv file. (The
            string-fields=FIPS argument prevents FIPS codes in the CSV file from being converted to numbers.)</p>
        <pre><code class="lang-bash">mapshaper states<span class="hljs-selector-class">.shp</span> -join demographics<span class="hljs-selector-class">.txt</span> keys=STATE_FIPS,FIPS string-fields=FIPS -o out.shp
        </code></pre>
        <h3 id="-lines">-lines</h3>
        <p>Converts points and polygons to lines. Polygons are converted to topological boundaries. Without the
            <code>&lt;fields&gt;</code> argument, external (unshared) polygon boundaries are attributed as
            <code>TYPE: &quot;outer&quot;, RANK: 0</code> and internal (shared) boundaries are
            <code>TYPE: &quot;inner&quot;, RANK: 1</code>. </p>
        <p><code>&lt;fields&gt;</code> or <code>fields=</code> (Optional) comma-separated list of attribute fields for
            creating a hierarchy of polygon boundaries. A single field name adds an intermediate level of hierarchy with
            attributes: <code>TYPE: &lt;field name&gt;, RANK: 1</code>, and the lowest-level internal boundaries are
            given attributes <code>TYPE: &quot;outer&quot;, RANK: 2</code>. A comma-separated list of fields adds
            additional levels of hierarchy.</p>
        <p><code>where=</code> Use a JS expression for filtering polygon boundaries using properties of adjacent
            polygons. The expression context has objects named A and B, which represent features on eather side of a
            path. B is null if a path only belongs to a single feature.</p>
        <p><code>each=</code> Apply a JS expression to each line (using A and B, like the <code>where=</code> option).
        </p>
        <p><code>groupby=</code> Convert a point layer into multiple lines, using a field value for grouping.</p>
        <p>Common options: <code>name=</code> <code>+</code> <code>target=</code></p>
        <pre><code class="lang-bash"># Example: Classify national, state <span class="hljs-keyword">and </span>county <span class="hljs-keyword">boundaries.
        </span><span class="hljs-symbol">mapshaper</span> counties.shp -lines STATE_FIPS -o <span class="hljs-keyword">boundaries.shp</span>
        </code></pre>
        <pre><code class="lang-bash"># Example: <span class="hljs-keyword">add</span> the names <span class="hljs-keyword">of</span> neighboring countries <span class="hljs-keyword">to</span> <span class="hljs-keyword">each</span> section <span class="hljs-keyword">of</span> border
        mapshaper countries.geojson \
          -lines <span class="hljs-keyword">each</span>=<span class="hljs-string">'COUNTRIES = A.NAME + (B ? "," + B.NAME : "")'</span> \
          -o borders.geojson
        </code></pre>
        <h3 id="-merge-layers">-merge-layers</h3>
        <p>Merge features from several layers into a single layer. Layers can only be merged if they have compatible
            geometry types. Target layers should also have compatible data fields, unless the <code>force</code> option
            is used.</p>
        <p><code>force</code> Allow merging layers with inconsistent fields. When a layer is missing a particular field,
            the field will be added, with the values set to <code>undefined</code>. Using this option, you are still
            prevented from merging fields with different data types (e.g. a field containing numbers in one layer and
            strings in another). You are also still prevented from merging layers containing different geometry types.
        </p>
        <p><code>flatten</code> (polygon layers) Remove polygon overlaps by assigning overlapping areas to the last
            overlapping polygon (the topmost feature if features are rendered in sequence).</p>
        <p>Common options: <code>name=</code> <code>target=</code></p>
        <pre><code class="lang-bash"><span class="hljs-comment"># Example: Combine features from several Shapefiles into a single Shapefile.</span>
        <span class="hljs-comment"># -i combine-files is used because files are processed separately by default.</span>
        mapshaper -i <span class="hljs-keyword">OR.shp </span>WA.<span class="hljs-keyword">shp </span>CA.<span class="hljs-keyword">shp </span>AK.<span class="hljs-keyword">shp </span>combine-files \
            -merge-layers \
            -o pacific_states.<span class="hljs-keyword">shp</span>
        </code></pre>
        <h3 id="-mosaic">-mosaic</h3>
        <p>Flatten a polygon layer by converting overlapping areas to separate polygons.</p>
        <p><code>calc=</code> Use a JavaScript expression to handle many-to-one aggregation (similar to the
            <code>calc=</code> option of the<code>-join</code> and <code>-dissolve</code> functions). See <a
                href="#-calc">-calc</a> for a list of supported functions.</p>
        <p>Common options: <code>name=</code> <code>+</code> <code>target=</code></p>
        <h3 id="-point-grid">-point-grid</h3>
        <p>Create a rectangular grid of points.</p>
        <p><code>&lt;cols,rows&gt;</code> Size of the grid, e.g. <code>-point-grid 100,100</code>.</p>
        <p><code>interval=</code> Distance between adjacent points, in source units (alternative to setting the number
            of cols and rows).</p>
        <p><code>bbox=</code> Fit the grid to a bounding box (xmin,ymin,xmax,ymax). Defaults to the bounding box of the
            other data layers, or of the world if no other layers are present.</p>
        <p><code>name=</code> Set the name of the point grid layer</p>
        <h3 id="-points">-points</h3>
        <p>Create a point layer, either from polygon or polyline geometry or from values in the attribute table. By
            default, polygon features are replaced by a single point located at the centroid of the polygon ring, or the
            largest ring of a multipart polygon. By default, polyline features are replaced by a single point located at
            the polyline vertex that is closest to the center of the feature&#39;s bounding box (this can be used to
            join polylines to polygons using a point-to-polygon spatial join).</p>
        <p><code>x=</code> Name of field containing x coordinate values. Common X-coordinate names are auto-detected
            (e.g. longitude, LON).</p>
        <p><code>y=</code> Name of field containing y coordinate values. Common Y-coordinate names are auto-detected
            (e.g. latitude, LAT).</p>
        <p><code>centroid</code> Create points at the centroid of the largest ring of each polygon feature. Point
            placement is currrently not affected by holes.</p>
        <p><code>inner</code> Create points in the interior of the largest ring of each polygon feature. Inner points
            are located away from polygon boundaries.</p>
        <p><code>vertices</code> Convert polygon and polyline features into point features containing the unique
            vertices in each shape.</p>
        <p><code>vertices2</code> Convert all the vertices in polygon and polyline features into points, including
            duplicate coordinates (e.g. the duplicate endpoint coordinates of polygon rings).</p>
        <p><code>endpoints</code> Capture the unique endpoints of polygon and polyline arcs.</p>
        <p><code>midpoints</code> Find the midpoint of each path in a polyline layer.</p>
        <p><code>interpolated</code> Interpolate points along polylines. Requires the <code>interval=</code> option to
            be set. Original vertices are replaced by interpolated vertices.</p>
        <p><code>interval=</code> Distance between interpolated points (in meters if coordinates are unprojected, or
            projected units).</p>
        <p>Common options: <code>name=</code> <code>+</code> <code>target=</code></p>
        <pre><code class="lang-bash"># Example: <span class="hljs-keyword">Create</span> points <span class="hljs-keyword">in</span> the interior <span class="hljs-keyword">of</span> <span class="hljs-keyword">each</span> polygon 
        mapshaper counties.shp -points inner -o points.shp
        
        # Example: <span class="hljs-keyword">Create</span> points <span class="hljs-keyword">in</span> the interior <span class="hljs-keyword">of</span> <span class="hljs-keyword">each</span> polygon (alternate <span class="hljs-function"><span class="hljs-keyword">method</span>) 
        <span class="hljs-title">mapshaper</span> <span class="hljs-title">counties</span>.<span class="hljs-title">shp</span> -<span class="hljs-title">each</span> '<span class="hljs-title">cx</span>=<span class="hljs-title">this</span>.<span class="hljs-title">innerX</span>, <span class="hljs-title">cy</span>=<span class="hljs-title">this</span>.<span class="hljs-title">innerY</span>' -<span class="hljs-title">points</span> <span class="hljs-title">x</span>=<span class="hljs-title">cx</span> <span class="hljs-title">y</span>=<span class="hljs-title">cy</span> -<span class="hljs-title">o</span> <span class="hljs-title">points</span>.<span class="hljs-title">shp</span></span>
        </code></pre>
        <h3 id="-polygons">-polygons</h3>
        <p>Convert a polyline layer to a polygon layer by linking together intersecting polylines to form rings.</p>
        <p><code>gap-tolerance=</code> Close gaps (&quot;undershoots&quot;) between polylines up to the distance
            specified by this option.</p>
        <p><code>from-rings</code> Convert a layer of closed polyline rings into polygons. Nested rings in multipart
            features are converted into holes.</p>
        <p>Common options: <code>target=</code></p>
        <h3 id="-proj">-proj</h3>
        <p>Project a dataset using a PROJ string, EPSG code or alias. This command affects all layers in the dataset(s)
            containing the targeted layer or layers. Information on PROJ string syntax can be found on the (PROJ
            website)[<a href="https://proj.org/usage/index.html#">https://proj.org/usage/index.html#</a>].</p>
        <p><code>&lt;crs&gt;</code> or <code>crs=</code> Target CRS, given as a Proj.4 definition or an alias. Use the
            <a href="#-projections"><code>-projections</code></a> command to list available projections and aliases. In
            projections which require additional parameters, such as a zone in UTM, you can pass a Proj4 string enclosed
            in quotes. For example, <code>crs=&#39;+proj=utm +zone=27&#39;</code>.</p>
        <p><code>densify</code> Interpolate vertices along long line segments as needed to approximate curved lines.</p>
        <p><code>match=</code> Match the projection of the given layer or .prj file.</p>
        <p><code>init=</code> Define the pre-projected coordinate system, if unknown. This option is not needed if the
            source coordinate system is defined by a .prj file, or if the source CRS is WGS84. As with <code>crs</code>,
            you can pass a Proj4 string enclosed in quotes if the selected projection requires extra parameters, for
            example <code>init=&#39;+proj=utm +zone=33&#39;</code>.</p>
        <p><code>target=</code> Layer(s) to target. All layers belonging to the same dataset as a targeted layer will be
            reprojected. To reproject all datasets, use <code>target=*</code>.</p>
        <p><strong>Examples</strong></p>
        <pre><code class="lang-bash"><span class="hljs-comment"># Convert a GeoJSON file to New York Long Island state plane CRS, using a Proj.4 string</span>
        mapshaper nyc.json -proj +<span class="hljs-attr">proj=lcc</span> +<span class="hljs-attr">lat_1=41.03333333333333</span> +<span class="hljs-attr">lat_2=40.66666666666666</span> \
        +<span class="hljs-attr">lat_0=40.16666666666666</span> +<span class="hljs-attr">lon_0=-74</span> +<span class="hljs-attr">x_0=300000</span> +<span class="hljs-attr">y_0=0</span> +<span class="hljs-attr">ellps=GRS80</span> +<span class="hljs-attr">datum=NAD83</span> +<span class="hljs-attr">units=m</span> \
        -o out.json
        
        <span class="hljs-comment"># Apply the same projection using an EPSG code</span>
        mapshaper nyc.json -proj EPSG:<span class="hljs-number">2831</span> -o out.json
        
        <span class="hljs-comment"># Convert a projected Shapefile to WGS84 coordinates</span>
        mapshaper area.shp -proj wgs84 -o out.shp
        
        <span class="hljs-comment"># Use the Winkel Tripel projection with a custom central meridian</span>
        mapshaper countries.shp -proj +<span class="hljs-attr">proj=wintri</span> +<span class="hljs-attr">lon_0=10</span> -o out.shp
        
        <span class="hljs-comment"># Shortcut notation for the above projection</span>
        mapshaper countries.shp -proj wintri +<span class="hljs-attr">lon_0=10</span> -o out.shp
        
        <span class="hljs-comment"># Convert an unprojected U.S. Shapefile into a composite projection with Alaska</span>
        <span class="hljs-comment"># and Hawaii repositioned and rescaled to fit in the lower left corner.</span>
        <span class="hljs-comment"># Show Puerto Rico and the U.S. Virgin Islands</span>
        <span class="hljs-comment"># Override the default central meridian and scale of the Alaska inset</span>
        mapshaper us_states.shp -proj albersusa +PR +VI +AK.<span class="hljs-attr">lon_0=-141</span> +AK.<span class="hljs-attr">scale=0.4</span> -o out.shp
        </code></pre>
        <h3 id="-rectangle">-rectangle</h3>
        <p>Create a new layer containing a rectangular polygon.</p>
        <p><code>bbox=&lt;xmin,ymin,xmax,ymax&gt;</code> Give the coordinates of the rectangle.</p>
        <p><code>source=</code> Create a bounding box around a given layer.</p>
        <p><code>aspect-ratio=</code> Aspect ratio as a number or range (e.g. 2 0.8,1.6 ,2).</p>
        <p><code>offset=</code> Padding as a distance or percentage of width/height (single value or list).</p>
        <p><code>name=</code> Assign a name to the newly created layer.</p>
        <h3 id="-rectangles">-rectangles</h3>
        <p>Create a new layer containing a rectangular polygon for each feature in the layer.</p>
        <p><code>aspect-ratio=</code> Aspect ratio as a number or range (e.g. 2 0.8,1.6 ,2).</p>
        <p><code>offset=</code> Padding as a distance or percentage of width/height (single value or list).</p>
        <p><code>name=</code> Assign a name to the newly created layer.</p>
        <h3 id="-rename-fields">-rename-fields</h3>
        <p>Rename data fields. To rename a field from A to B, use the assignment operator: B=A.</p>
        <p><code>&lt;fields&gt;</code> or <code>fields=</code> List of fields to rename as a comma-separated list. </p>
        <p>Common options: <code>target=</code></p>
        <pre><code class="lang-bash"># Example: rename STATE_FIPS <span class="hljs-keyword">to</span> FIPS <span class="hljs-keyword">and</span> STATE_NAME <span class="hljs-keyword">to</span> <span class="hljs-keyword">NAME</span>
        mapshaper states.shp -rename-fields FIPS=STATE_FIPS,<span class="hljs-keyword">NAME</span>=STATE_NAME -o <span class="hljs-keyword">out</span>.shp
        </code></pre>
        <h3 id="-rename-layers">-rename-layers</h3>
        <p>Assign new names to layers. If fewer names are given than there are layers, the last name in the list is
            repeated with numbers appended (e.g. layer1, layer2).</p>
        <p><code>&lt;names&gt;</code> or <code>names=</code> One or more layer names (comma-separated).</p>
        <p><code>target=</code> Rename a subset of all layers.</p>
        <pre><code class="lang-bash"><span class="hljs-comment"># Example: Create a TopoJSON file with sensible object names.</span>
        mapshaper ne_50m_rivers_lake_centerlines.shp ne_50m_land.shp <span class="hljs-built_in">combine</span>-<span class="hljs-built_in">files</span> \
          -<span class="hljs-built_in">rename</span>-layers water,land -o target=* layers.topojson
        </code></pre>
        <h3 id="-require">-require</h3>
        <p>Require a Node module or ES module for use in commands like <code>-each</code> and <code>-run</code>. Modules
            are added to the expression context. When the <code>alias=</code> option is given, modules are accessed via
            their aliases. Modules that are imported by name (e.g. <code>-require d3</code>) are accessed via their
            name, or by their alias if the <code>alias=</code> option is used. Module files without an alias name have
            their exported functions and data added directly to the expression context.</p>
        <p><code>&lt;module&gt;</code> or <code>module=</code> Name of an installed module or path to a module file.</p>
        <p><code>alias=</code> Import the module as a custom-named variable.</p>
        <pre><code class="lang-bash"># Example: use the underscore module (which has been installed locally)
        $ mapshaper data.json \
            -<span class="ruby"><span class="hljs-keyword">require</span> underscore <span class="hljs-keyword">alias</span>=<span class="hljs-number">_</span> \
        </span>    -<span class="ruby">each <span class="hljs-string">'id = _.uniqueId()'</span> \
        </span>    -<span class="ruby">o data2.json</span>
        </code></pre>
        <pre><code class="lang-bash"><span class="hljs-comment"># Example: import a module file containing a user-defined function </span>
        $ mapshaper data.json <span class="hljs-string">\</span>
          -<span class="hljs-built_in">require</span> scripts/includes.mjs <span class="hljs-string">\</span>
          -each <span class="hljs-string">'displayname = getDisplayName(d)'</span> <span class="hljs-string">\</span>
          -o data2.json
        </code></pre>
        <h3 id="-run">-run</h3>
        <p>Create mapshaper commands on-the-fly and run them.</p>
        <p><code>&lt;expression&gt;</code> or <code>expression=</code> A JS expression or template containing embedded
            expressions, for generating one or more mapshaper commands.</p>
        <ul>
            <li>Embedded expressions are enclosed in curly braces (see below).</li>
            <li>Expressions can access <code>target</code> and <code>io</code> objects.</li>
            <li>Expressions can also access functions and data loaded with the <code>-require</code> command.</li>
            <li>Functions can be async.</li>
        </ul>
        <p>Expression context:</p>
        <p><code>target</code> object provides data and information about the command&#39;s target layer</p>
        <ul>
            <li><code>target.layer_name</code> Name of layer</li>
            <li><code>target.geojson</code> (getter) Returns a GeoJSON FeatureCollection for the layer</li>
            <li><code>target.geometry_type</code> One of: polygon, polyline, point, <code>undefined</code></li>
            <li><code>target.feature_count</code> Number of features in the layer</li>
            <li><code>target.null_shape_count</code> Number of features with null geometry</li>
            <li><code>target.null_data_count</code> Number of features with no attribute data</li>
            <li><code>target.bbox</code> GeoJSON-style bounding box</li>
            <li><code>target.proj4</code> PROJ-formatted string giving the CRS (coordinate reference system) of the
                layer</li>
        </ul>
        <p><code>io</code> object has a method for passing data to the <code>-i</code> command.</p>
        <ul>
            <li><code>io.ifile(&lt;filename&gt;, &lt;data&gt;)</code> Create a temp file to use as input in a
                <code>-run</code> command (see example 2 below)</li>
        </ul>
        <p><strong>Example 1:</strong> Apply a custom projection based on the layer extent.</p>
        <pre><code class="lang-bash">$ mapshaper -<span class="hljs-selector-tag">i</span> country<span class="hljs-selector-class">.shp</span> -require projection<span class="hljs-selector-class">.js</span> -run <span class="hljs-string">'-proj {tmerc(target.bbox)}'</span> -o
        </code></pre>
        <pre><code class="lang-javascript"><span class="hljs-comment">// contents of projection.js file</span>
        <span class="hljs-built_in">module</span>.exports.tmerc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bbox</span>) </span>{
          <span class="hljs-keyword">var</span> lon0 = (bbox[<span class="hljs-number">0</span>] + bbox[<span class="hljs-number">2</span>]) / <span class="hljs-number">2</span>,
              lat0 = (bbox[<span class="hljs-number">1</span>] + bbox[<span class="hljs-number">3</span>]) / <span class="hljs-number">2</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-string">`+proj=tmerc lat_0=<span class="hljs-subst">${lat0}</span> lon_0=<span class="hljs-subst">${lon0}</span>`</span>;
        };
        </code></pre>
        <p><strong>Example 2:</strong> Convert points to a Voronoi diagram using a template expression
            together with an external script.</p>
        <pre><code class="lang-bash">$ mapshaper points.geojson \
          -<span class="ruby"><span class="hljs-keyword">require</span> script.js \
        </span>  -<span class="ruby">run <span class="hljs-string">'-i {io.ifile("voronoi.json", voronoi(target.geojson, target.bbox))}'</span> \
        </span>  -<span class="ruby">o</span>
        </code></pre>
        <pre><code class="lang-javascript"><span class="hljs-comment">// contents of script.js file</span>
        <span class="hljs-built_in">module</span>.exports.voronoi = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">points, bbox</span>) </span>{
          <span class="hljs-keyword">const</span> d3 = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'d3-delaunay'</span>); <span class="hljs-comment">// installed locally</span>
          <span class="hljs-keyword">const</span> coords = points.features.map(<span class="hljs-function"><span class="hljs-params">feat</span> =&gt;</span> feat.geometry.coordinates);
          <span class="hljs-keyword">const</span> voronoi = d3.Delaunay.from(coords).voronoi(bbox);
          <span class="hljs-keyword">const</span> features = <span class="hljs-built_in">Array</span>.from(voronoi.cellPolygons()).map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ring, i</span>) </span>{
            <span class="hljs-keyword">return</span> {
              <span class="hljs-attr">type</span>: <span class="hljs-string">'Feature'</span>,
              <span class="hljs-attr">properties</span>: points.features[i].properties,
              <span class="hljs-attr">geometry</span>: {
                <span class="hljs-attr">type</span>: <span class="hljs-string">'Polygon'</span>,
                <span class="hljs-attr">coordinates</span>: [ring]
              }
            };
          });
          <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">'FeatureCollection'</span>, <span class="hljs-attr">features</span>: features};
        };
        </code></pre>
        <h3 id="-scalebar">-scalebar</h3>
        <p>Add a scale bar to an SVG map. The command creates a data-only layer containing the scale bar&#39;s data
            properties. A scale bar is rendered if the layer is included in SVG output. If no <code>label</code>
            property is given, the text, length and units will be assigned automatically.</p>
        <p><code>&lt;label&gt;</code> or <code>label=</code> Label giving the size and units of the scalebar, e.g.
            <code>&quot;25 k.m.&quot;</code>.</p>
        <h3 id="-shape">-shape</h3>
        <p>Create a new layer containing a single polyline or polygon shape.</p>
        <p><code>coordinates=&lt;x,y,...&gt;</code> Specify vertex coordinates as a comma-separated list.</p>
        <p><code>offsets=&lt;dx,dy,...&gt;</code> Specify vertex coordinates as a list of offsets from the previous
            vertex. The first vertex in the list is offset from the last coordinate in the <code>coordinates=</code>
            list.</p>
        <p><code>closed</code> Close an open path to form a polygon shape.</p>
        <p><code>name=</code> Assign a name to the newly created layer.</p>
        <h3 id="-simplify">-simplify</h3>
        <p>Mapshaper supports Douglas-Peucker simplification and two kinds of Visvalingam simplification.</p>
        <p>Douglas-Peucker (a.k.a. Ramer-Douglas-Peucker) produces simplified lines that remain within a specified
            distance of the original line. It is effective for thinning dense vertices but tends to form spikes at high
            simplification.</p>
        <p>Visvalingam simplification iteratively removes the least important point from a polyline. The importance of
            points is measured using a metric based on the geometry of the triangle formed by each non-endpoint vertex
            and the two neighboring vertices. The <code>visvalingam</code> option uses the &quot;effective area&quot;
            metric &mdash; points forming smaller-area triangles are removed first.</p>
        <p>Mapshaper&#39;s default simplification method uses Visvalingam simplification but weights the effective area
            of each point so that smaller-angle vertices are preferentially removed, resulting in a smoother appearance.
        </p>
        <p>When working with multiple polygon and polyline layers, the <code>-simplify</code> command is applied to all
            of the layers.</p>
        <p><strong>Options</strong></p>
        <p><code>&lt;percentage&gt;</code> or <code>percentage=</code> Percentage of removable points to retain. Accepts
            values in the range <code>0%-100%</code> or <code>0-1</code>.</p>
        <p><code>dp</code> <code>rdp</code> Use Douglas-Peucker simplification.</p>
        <p><code>visvalingam</code> Use Visvalingam simplification with the &quot;effective area&quot; metric.</p>
        <p><code>weighted</code> Use weighted Visvalingam simplification (this is the default). Points located at the
            vertex of more acute angles are preferentially removed, for a smoother appearance.</p>
        <p><code>weighting=</code> Coefficient for weighting Visvalingam simplification (default is 0.7). Higher values
            produce smoother output. <code>weighting=0</code> is equivalent to unweighted Visvalingam simplification.
        </p>
        <p><code>resolution=</code> Use an output resolution (e.g. <code>1000x800</code>) to control the amount of
            simplification.</p>
        <p><code>interval=</code> Specify simplification amount in units of distance. Uses meters when simplifying
            unprojected datasets in 3D space (see <code>planar</code> option below), otherwise uses the same units as
            the source data.</p>
        <p><code>variable</code> Apply a variable amount of simplification to the paths in a polygon or polygon layer.
            This flag changes the <code>interval=</code>, <code>percentage=</code> and <code>resolution=</code> options
            to accept JavaScript expressions instead of literal values. (See the <code>-each</code> command for
            information on mapshaper JS expressions).</p>
        <p><code>planar</code> By default, mapshaper simplifies decimal degree coordinates in 3D space (using geocentric
            x,y,z coordinates). The <code>planar</code> option treats lng,lat coordinates as x,y coordinates on a
            Cartesian plane.</p>
        <p><code>keep-shapes</code> Prevent polygon features from disappearing at high simplification. For multipart
            features, mapshaper preserves the part with the largest original bounding box.</p>
        <p><code>no-repair</code> By default, mapshaper rolls back simplification along pairs of intersecting line
            segments by re-introducing removed points until either the intersection disappears or there are no more
            points to add. This option disables intersection repair.</p>
        <p><code>stats</code> Display summary statistics relating to the geometry of simplified paths.</p>
        <p><strong>Examples</strong></p>
        <pre><code class="lang-bash"># Simplify counties.shp using the <span class="hljs-section">default</span> algorithm, retaining <span class="hljs-number">10</span>% of removable vertices.
        mapshaper counties.shp -simplify <span class="hljs-number">10</span>% -o simplified.shp
        
        # Use Douglas-Peucker simplification with a <span class="hljs-number">100</span> meter threshold.
        mapshaper states.shp -simplify dp interval=<span class="hljs-number">100</span> -o simplified/
        </code></pre>
        <h3 id="-snap">-snap</h3>
        <p>Snap together nearby vertices</p>
        <p><code>interval</code> Snap tolerance (default is small).</p>
        <p><code>endpoints</code> Only snap endpoints of polyline features.</p>
        <p><code>precision=</code> Tound all coordinates to a given decimal precision (e.g. 0.000001).</p>
        <p><a href="#common-options"><code>target=</code></a></p>
        <h3 id="-sort">-sort</h3>
        <p>Sort features in a data layer using a JavaScript expression.</p>
        <p><code>&lt;expression&gt;</code> or <code>expression=</code> Apply a JavaScript expression to each feature,
            using the resulting values for sorting the features. Uses the same execution environment as <a
                href="#-each"><code>-each</code></a>.</p>
        <p><code>ascending</code> Sort in ascending order (this is the default).</p>
        <p><code>descending</code> Sort in descending order.</p>
        <p><a href="#common-options"><code>target=</code></a></p>
        <h3 id="-split">-split</h3>
        <p>Distributes features in the target layer to multiple output layers. If the <code>expression=</code> option is
            present, features with the same value are grouped together. The value of the expression is used to name the
            split-apart fields. If no argument is supplied, split-apart layers are numbered.</p>
        <p><code>&lt;expression&gt;</code> or <code>expression=</code> JS expression or name of the attribute field to
            split on.</p>
        <p>Common options: <code>+</code> <code>target=</code></p>
        <p><strong>Examples</strong></p>
        <pre><code class="lang-bash"><span class="hljs-comment"># Split features from a named layer into new GeoJSON files using a data field.</span>
        <span class="hljs-comment"># Output names use the original layer name + data values,</span>
        <span class="hljs-comment"># e.g. states-AK.json, states-AL.json, etc.</span>
        mapshaper states.shp -<span class="hljs-built_in">split</span> STATE -o <span class="hljs-built_in">format</span>=geojson
        
        <span class="hljs-comment"># Split features from an unnamed layer into new GeoJSON files using a data field.</span>
        <span class="hljs-comment"># Output names contain data values,</span>
        <span class="hljs-comment"># e.g. AK.json, AL.json, etc.</span>
        mapshaper states.shp name=<span class="hljs-string">''</span> -<span class="hljs-built_in">split</span> STATE -o <span class="hljs-built_in">format</span>=geojson
        
        <span class="hljs-comment"># Split source features into individual GeoJSON files (no data field supplied).</span>
        <span class="hljs-comment"># Output names use source layer name + ascending number,</span>
        <span class="hljs-comment"># e.g. states-1, states-2, etc.</span>
        mapshaper states.shp -<span class="hljs-built_in">split</span> -o <span class="hljs-built_in">format</span>=geojson
        </code></pre>
        <h3 id="-split-on-grid">-split-on-grid</h3>
        <p>Split features into separate layers using a grid of cols,rows cells. Useful for dividing a large dataset into
            smaller files that can be loaded dynamically into an interactive map. Use <code>-o bbox-index</code> to
            export a file containing the name and bounding box of the shapes in each file. Empty cells are removed from
            the output.</p>
        <p><code>&lt;cols,rows&gt;</code> Size of the grid, e.g. <code>-split-on-grid 12,10</code></p>
        <p>Common options: <code>target=</code> </p>
        <h3 id="-subdivide">-subdivide</h3>
        <p>Recursively divide a layer using a boolean JS expression. The expression is first evaluated against all
            features in the layer. If true, the features are spatially partitioned either vertically or horizontally,
            according to whether the aggregate bounding box is relatively tall or wide. See example below.</p>
        <p>Subdivide expressions can call several functions that operate on a group of features. The <code>sum()</code>
            function takes a feature-level expression as an argument and returns the summed result after applying the
            expression to each feature in the group. Similar functions include <code>min()</code> <code>max()</code>
            <code>average()</code> and <code>median()</code>.</p>
        <p><code>&lt;expression&gt;</code> or <code>expression=</code> Boolean JavaScript expression</p>
        <p>Common options: <code>target=</code></p>
        <p><strong>Example</strong></p>
        <pre><code class="lang-bash"># Aggregate census tracts into groups of less than 1,000,000 population and less than 100 sq km in area.
        mapshaper tracts.shp
          -<span class="ruby">subdivide <span class="hljs-string">"sum('POPULATION') &gt;= 1000000 &amp;&amp; sum('this.area') &gt; 1e8"</span> \
        </span>  -<span class="ruby">dissolve sum-fields=POPULATION \
        </span>  -<span class="ruby">merge-layers \
        </span>  -<span class="ruby">o tract_groups.shp</span>
        </code></pre>
        <h3 id="-style">-style</h3>
        <p>Add common SVG attributes for SVG export and display in the web UI. Attribute values take either a literal
            value or a JS expression. See the <a href="#-each"><code>-each</code></a> command for help with expressions.
            This command was named <code>-svg-style</code> in earlier versions of mapshaper.</p>
        <p><code>where=</code> Boolean JS expression for targetting a subset of features.</p>
        <p><code>class=</code> One or more CSS classes, separated by spaces (e.g.
            <code>class=&quot;light semi-transparent&quot;</code>)</p>
        <p><code>css=</code> Inline CSS to use as the <code>style=</code> attribute of each SVG symbol.</p>
        <p><code>fill=</code> Fill color (e.g. <code>#eee</code> <code>pink</code> <code>rgba(0, 0, 0, 0.2)</code>)</p>
        <p><code>fill-pattern=</code> Definition string for a pattern. There are four pattern types: hatches, dots,
            squares and dashes. The syntax for each pattern is:</p>
        <ul>
            <li>hatches [rotation] width1 color1 [width2 color2 ...]</li>
            <li>dots [rotation] size color1 [color2 ...] spacing background-color</li>
            <li>squares [rotation] size color1 [color2 ...] spacing background-color</li>
            <li>dashes [rotation] dash-length space-length line-width color line-spacing background-color</li>
        </ul>
        <p>Example: <code>hatches 45deg 2px red 2px grey</code></p>
        <p><code>fill-effect=sphere</code> Add a gradient effect to the bounding circle of a globe projection (e.g.
            <code>ortho</code> <code>npers</code>) to create a 3d effect.</p>
        <p><code>stroke=</code> Stroke color</p>
        <p><code>stroke-width=</code> Stroke width</p>
        <p><code>stroke-dasharray=</code> Dashes</p>
        <p><code>opacity=</code> Symbol opacity (e.g. <code>opacity=0.5</code>)</p>
        <p><code>r=</code> Circle radius. Setting this exports points as SVG <code>&lt;circle&gt;</code> symbols, unless
            the <code>-o point-symbol=square</code> option is used.</p>
        <p><code>label-text=</code> Label text (set this to export points as labels). To create multiline labels, insert
            line delimiters into the label text. There are three possible line delimiters: the newline character,
            <code>\n</code> (backslash + &quot;n&quot;), and <code>&lt;br&gt;</code>. (When importing JSON data,
            <code>\n</code> in a JSON string is parsed as a newline and <code>\\n</code> is parsed as backslash +
            &quot;n&quot;). Note that Mapshaper doesn&#39;t accept multiline strings as input on the command line.</p>
        <p><code>text-anchor=</code> Horizontal justification of label text. Possible values are: start, end or middle
            (the default).</p>
        <p><code>dx=</code> X offset of labels (default is 0)</p>
        <p><code>dy=</code> Y offset of labels (default is baseline-aligned)</p>
        <p><code>font-size=</code> Size of label text (default is 12)</p>
        <p><code>font-family=</code> CSS font family of labels (default is sans-serif)</p>
        <p><code>font-weight=</code> CSS font weight property of labels (e.g. bold, 700)</p>
        <p><code>font-style=</code> CSS font style property of labels (e.g. italic)</p>
        <p><code>letter-spacing=</code> CSS letter-spacing property of labels</p>
        <p><code>line-height=</code> Line spacing of multi-line labels (default is 1.1em). Lines are separated by
            newline characters in the label text.</p>
        <p>Common options: <code>target=</code></p>
        <p><strong>Example</strong></p>
        <pre><code class="lang-bash"># Apply a <span class="hljs-number">2</span>px grey <span class="hljs-built_in">stroke</span> and no <span class="hljs-built_in">fill</span> to a polygon layer
        mapshaper polygons.geojson \
        -style <span class="hljs-built_in">fill</span>=none <span class="hljs-built_in">stroke</span>=<span class="hljs-string">'#aaa'</span> <span class="hljs-built_in">stroke</span>-<span class="hljs-built_in">width</span>=<span class="hljs-number">2</span> \
        -o out.svg
        </code></pre>
        <h3 id="-symbols">-symbols</h3>
        <p>Symbolize points as regular polygons, circles, stars, arrows and other shapes.</p>
        <p><code>type=</code> Basic types: star, polygon, circle, arrow, ring. Aliases: triangle, square, pentagon, etc.
        </p>
        <p><code>fill=</code> Symbol fill color</p>
        <p><code>stroke=</code> Symbol line color (linear symbols only)</p>
        <p><code>stroke-width=</code> Symbol line width (linear symbols only)</p>
        <p><code>opacity=</code> Symbol opacity</p>
        <p><code>geographic</code> Make geographic shapes (polygons or polylines) instead of SVG objects</p>
        <p><code>pixel-scale=</code> Set symbol scale in meters-per-pixel (for polygons option)</p>
        <p><code>rotated</code> Symbol is rotated to an alternate orientation</p>
        <p><code>rotation=</code> Rotation of symbol in degrees</p>
        <p><code>scale=</code> Scale symbols by a multiplier</p>
        <p><code>radius=</code> Distance from center to farthest point on the symbol</p>
        <p><code>sides=</code> (polygon) number of sides of a polygon symbol</p>
        <p><code>points=</code> (star) number of points</p>
        <p><code>point-ratio=</code> (star) ratio of minor to major radius of star</p>
        <p><code>radii=</code> (ring) comma-sep. list of concentric radii, ascending order</p>
        <p><code>length=</code> (arrow) length of arrow in pixels</p>
        <p><code>direction=</code> (arrow) angle off of vertical (-90 = left-pointing)</p>
        <p><code>head-angle=</code> (arrow) angle of tip of arrow (default is 40 degrees)</p>
        <p><code>head-width=</code> (arrow) width of arrow head from side to side</p>
        <p><code>head-length=</code> (arrow) length of head (alternative to head-angle). Use <code>head-length=0</code>
            to make headless arrows (i.e. simple lines)</p>
        <p><code>stem-width=</code> (arrow) width of stem at its widest point</p>
        <p><code>stem-length=</code> (arrow) alternative to length</p>
        <p><code>stem-taper=</code> (arrow) factor for tapering the width of the stem (0-1)</p>
        <p><code>stem-curve=</code> (arrow) curvature in degrees (default is 0)</p>
        <p><code>min-stem-ratio=</code> (arrow) minimum ratio of stem to total length. This option scales down the
            entire symbol instead of making the stem shorter than the given ratio.</p>
        <p><code>anchor=</code> (arrow) takes one of: start, middle, end (default is start)</p>
        <p>Common options: <code>name=</code> <code>+</code> <code>target=</code></p>
        <h3 id="-union">-union</h3>
        <p>Create a composite layer (a polygon mosaic without overlaps) from two or more target polygon layers.</p>
        <p>Data values are copied from source features to output features. (Areal interpolation may
            be added in the future. The <code>-join</code> command currently supports areal interpolation between
            polygon layers using the <code>-join interpolate=&lt;fields&gt;</code> option.) Same-named fields in source
            layers are renamed in the output layer. For example, two source-layer fields named &quot;id&quot; will be
            renamed to &quot;id_1&quot; and &quot;id_2&quot;.</p>
        <p><code>fields=</code> Fields to retain (default is all fields).</p>
        <p>Common options: <code>name=</code> <code>+</code> <code>target=</code></p>
        <h3 id="-uniq">-uniq</h3>
        <p>Delete features with the same id as a previous feature</p>
        <p><code>&lt;expression&gt;</code> or <code>expression=</code> JS expression to obtain the id of a feature. Uses
            the same expression syntax as <a href="#-each"><code>-each</code></a>.</p>
        <p><code>max-count=</code> Allow multiple features with the same id (default is 1).</p>
        <p><code>invert</code> Retain only features that would ordinarily be deleted by <code>-uniq</code>.</p>
        <p><code>verbose</code> Print information about each removed feature.</p>
        <p><code>target=</code></p>
        <pre><code class="lang-bash"># Example: Retain only the largest parts of each multipart polygon
        mapshaper polygons.shp \
            -<span class="ruby">each <span class="hljs-string">'fid = this.id'</span> \
        </span>    -<span class="ruby">explode \
        </span>    -<span class="ruby">sort <span class="hljs-string">'this.area'</span> descending \
        </span>    -<span class="ruby">uniq <span class="hljs-string">'fid'</span> \
        </span>    -<span class="ruby">o out.shp</span>
        </code></pre>
        <h2 id="control-flow-commands">Control Flow Commands</h2>
        <h3 id="-if">-if</h3>
        <p>The <code>if</code> command runs the following commands if a condition is met.</p>
        <p><code>&lt;expression&gt;</code> or <code>expression=</code> Use a JavaScript expression to test a condition.
        </p>
        <p><code>empty</code> Test if layer is empty.</p>
        <p><code>not-empty</code> Test if layer contains data.</p>
        <p><code>layer=</code> Name or id of layer to test (default is current target layer).</p>
        <p><strong>Properties of <code>this</code></strong></p>
        <ul>
            <li><code>this.name</code> Layer name, or <undefined> if layer is unnamed.</li>
            <li><code>this.size</code> Number of features in the layer.</li>
            <li><code>this.empty</code> True if layer contains 0 features.</li>
            <li><code>this.data</code> Array of attribute data records, one object per feature.</li>
            <li><code>this.type</code> Geometry type, one of: polygon, polyline, point, <undefined>.</li>
            <li><code>this.bbox</code> An array [xmin, ymin, xmax, ymax] with additional properties: cx, cy, height,
                width, left, bottom, top, right.</li>
        </ul>
        <p><strong>Functions of <code>this</code></strong></p>
        <ul>
            <li><code>this.field_exists(&lt;name&gt;)</code> Tests if a data field exists in the target layer.</li>
            <li><code>this.field_type(&lt;name&gt;)</code> Returns the data type of a field, or <code>null</code> if a
                field is empty or missing. Types include:
                <code>&quot;string&quot; &quot;number&quot; &quot;boolean&quot; &quot;date&quot; &quot;object&quot;</code>.
                If a field includes multiple data types (which may occur in GeoJSON), the type of the first non-empty
                data value is returned.</li>
            <li><code>this.field_includes(&lt;value&gt;)</code> Tests if a given value occurs at least once in a data
                field.</li>
            <li><code>this.file_exists(&lt;filename&gt;)</code> Tests if a file exists.</li>
        </ul>
        <p><strong>Example</strong></p>
        <pre><code class="lang-bash">mapshaper -<span class="hljs-selector-tag">i</span> shapes<span class="hljs-selector-class">.json</span> -<span class="hljs-keyword">if</span> <span class="hljs-string">'!this.empty'</span> -dissolve -o out/dissolved.json
        </code></pre>
        <h3 id="-elif">-elif</h3>
        <p>One or more <code>-elif</code> (short for &quot;else if&quot;) commands may be added to test for alternate
            conditions, following an <code>-if</code> statement. The <code>-elif</code> command accepts the same options
            as the <code>-if</code> command.</p>
        <h3 id="-else">-else</h3>
        <p>Run the following commands if all preceding -if/-elif conditions are false.</p>
        <h3 id="-endif">-endif</h3>
        <p>Mark the end of an -if/-elif/-else sequence.</p>
        <h3 id="-stop">-stop</h3>
        <p>Stop processing (skip remaining commands). Useful when writing scripts, in combination with -if/-elif/-else.
        </p>
        <p><strong>Example</strong></p>
        <pre><code class="lang-bash"><span class="hljs-comment"># Don't try to process a missing file</span>
        mapshaper -<span class="hljs-keyword">if</span> '!file_exists(<span class="hljs-string">"boundaries.geojson"</span>)' -stop -<span class="hljs-keyword">endif</span> \
          -i boundaries.geojson -proj robin -o output/boundaries.shp
        </code></pre>
        <h3 id="-target">-target</h3>
        <p>Set the target layer or layers for the following command.</p>
        <p><code>&lt;target&gt;</code> or <code>target=</code> Name or id of a layer (first layer is 1).</p>
        <p><code>type=</code> Type of layer(s) to match (polygon, polyline or point). This is useful when importing
            GeoJSON files containing several types of geometry.</p>
        <p><code>name=</code> Rename the target layer.</p>
        <h2 id="informational-commands">Informational Commands</h2>
        <h3 id="-calc">-calc</h3>
        <p>Perform calculations on a collection of records and display the results, using a JavaScript expression. The
            expression can use one or more of the following built-in functions. Most functions take the name of a data
            field or a JS expression as the first argument.</p>
        <p>The <code>calc</code> functions are also available in the context of <code>calc=</code> expressions, which
            can be used as options to <code>-join</code>, <code>-dissolve</code> and several other commands. See example
            below.</p>
        <table>
            <thead>
                <tr>
                    <th>function</th>
                    <th>description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>count ()</code></td>
                    <td>returns number of records in the collection</td>
                </tr>
                <tr>
                    <td><code>sum (&lt;expr&gt;)</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td><code>mean (&lt;expr&gt;)</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td><code>average (&lt;expr&gt;)</code></td>
                    <td>same as mean()</td>
                </tr>
                <tr>
                    <td><code>median (&lt;expr&gt;)</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td><code>mode (&lt;expr&gt;)</code></td>
                    <td>returns most frequently occuring value in the collection (or the first such value in case of a
                        tie).</td>
                </tr>
                <tr>
                    <td><code>min (&lt;expr&gt;)</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td><code>max (&lt;expr&gt;)</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td><code>quartile1 (&lt;expr&gt;)</code></td>
                    <td>first quartile</td>
                </tr>
                <tr>
                    <td><code>quartile2 (&lt;expr&gt;)</code></td>
                    <td>same as median()</td>
                </tr>
                <tr>
                    <td><code>quartile3 (&lt;expr&gt;)</code></td>
                    <td>third quartile</td>
                </tr>
                <tr>
                    <td><code>iqr (&lt;expr&gt;)</code></td>
                    <td>interquartile range</td>
                </tr>
                <tr>
                    <td><code>quantile (&lt;expr&gt;, &lt;pct&gt;)</code></td>
                    <td>arbitrary percentile (<code>&lt;pct&gt;</code> is 0-1)</td>
                </tr>
                <tr>
                    <td><code>collect (&lt;expr&gt;)</code></td>
                    <td>returns array containing all values</td>
                </tr>
                <tr>
                    <td><code>collectIds ()</code></td>
                    <td>returns array of feature indexes (features are indexed 0 to n-1)</td>
                </tr>
                <tr>
                    <td><code>first (&lt;expr&gt;)</code></td>
                    <td>returns first value in the collection</td>
                </tr>
                <tr>
                    <td><code>last (&lt;expr&gt;)</code></td>
                    <td>returns last value in the collection</td>
                </tr>
                <tr>
                    <td><code>every (&lt;expr&gt;)</code></td>
                    <td>returns true if expression is true for all elements in the collection</td>
                </tr>
                <tr>
                    <td><code>some (&lt;expr&gt;)</code></td>
                    <td>returns true if expression is true for one or more elements in the collection</td>
                </tr>
            </tbody>
        </table>
        <p>Argument expressions take the same form as <code>-each</code> expressions. If no records are processed,
            <code>count()</code> and <code>sum()</code> return <code>0</code>, and the other functions return
            <code>null</code>.</p>
        <p><strong>Assignments</strong></p>
        <p>The <code>-calc</code> expression can take the form of one or more assignments. This creates global variables
            that can be accessed by subsequent expressions using the <code>global</code> namespace. For example:</p>
        <pre><code>mapshaper data.csv \
          -<span class="ruby">calc <span class="hljs-string">'N = count()'</span> \
        </span>  -<span class="ruby"><span class="hljs-keyword">if</span> <span class="hljs-string">'global.N &lt; 5'</span> \
        </span>  -<span class="ruby">print <span class="hljs-string">'LOW SAMPLE SIZE, STOPPING'</span> \
        </span>  -<span class="ruby">stop \
        </span>  -<span class="ruby">endif</span>
        </code></pre>
        <p><strong>Options</strong></p>
        <p><code>&lt;expression&gt;</code> or <code>expression=</code> JS expression containing calls to one or more
            <code>-calc</code> functions.</p>
        <p><code>where=</code> Perform calculations on a subset of records, using a boolean JS expression as a filter
            (similar to <a href="#-filter"><code>-filter</code></a> command).
            <code>+</code> Save output to a layer.
            <code>name=</code> Name the output layer (default name is &quot;calc&quot;).
            <code>target=</code>
        </p>
        <p><strong>Examples</strong></p>
        <pre><code class="lang-bash"># Calculate the sum <span class="hljs-keyword">of</span> a data field
        mapshaper ny-census-blocks.shp -calc <span class="hljs-string">'sum(POPULATION)'</span>
        
        # Count census blocks <span class="hljs-keyword">in</span> NY <span class="hljs-keyword">with</span> zero population
        mapshaper ny-census-blocks.shp -calc <span class="hljs-string">'count()'</span> <span class="hljs-keyword">where</span>=<span class="hljs-string">'POPULATION == 0'</span>
        
        # Using calc functions <span class="hljs-keyword">in</span> conjunction <span class="hljs-keyword">with</span> the `-dissolve` command
        mapshaper counties.csv -dissolve STATE_NAME calc=<span class="hljs-string">'NUM_COUNTIES = count()'</span> -o states.csv
        </code></pre>
        <h3 id="-colors">-colors</h3>
        <p>Print list of built-in color schemes. Color schemes can be used with the <code>color-scheme=</code> option of
            the <a href="#-classify">-classify</a> command. (These color schemes come from the <a
                href="https://github.com/d3/d3-scale-chromatic">d3-scale-chromatic</a> library.)</p>
        <h3 id="-comment">-comment</h3>
        <p>The following text up to the next command is treated as a comment. Useful for adding explanatory comments to
            a long sequence of commands.</p>
        <h3 id="-encodings">-encodings</h3>
        <p>Print list of supported text encodings (for .dbf import).</p>
        <h3 id="-help">-help</h3>
        <p>Print usage tips and a list of commands.</p>
        <p><code>&lt;command&gt;</code> Show options for a single command, e.g. <code>mapshaper -h join</code>.</p>
        <h3 id="-info">-info</h3>
        <p>Print information about a dataset. Useful for seeing the fields in a layer&#39;s attribute data table. Also
            useful for summarizing the result of a series of commands, or for debugging unexpected output.</p>
        <pre><code class="lang-bash"><span class="hljs-comment"># Example: Get information about an unknown GeoJSON or TopoJSON dataset</span>
        <span class="hljs-attribute">mapshaper</span> mystery_file.json -<span class="hljs-literal">info</span>
        </code></pre>
        <p><code>save-to=</code> Save information to a .json file.
            <code>+</code> Save output to a layer.
            <code>name=</code> Name the output layer (default name is &quot;info&quot;).
        </p>
        <h3 id="-inspect">-inspect</h3>
        <p>Print information about the data attributes of a feature.</p>
        <p><code>&lt;expression&gt;</code> or <code>expression=</code> JS expression for selecting a feature (see the <a
                href="#-each"><code>-each</code></a> command for documentation about JS expressions).</p>
        <p>Common options: <code>target=</code></p>
        <pre><code class="lang-bash"><span class="hljs-comment"># Example: View attribute data for a state</span>
        <span class="hljs-attribute">mapshaper</span> states.geojson -inspect <span class="hljs-string">'NAME == "Delaware"'</span>
        </code></pre>
        <h3 id="-print">-print</h3>
        <p>Prints a message to the console or terminal (using stdout). This command is useful in combination with the
            <code>-if/-elif/-else</code> commands.</p>
        <pre><code class="lang-bash"><span class="hljs-comment"># Example</span>
        mapshaper cities.json <span class="hljs-string">\</span>
        -<span class="hljs-keyword">if</span> <span class="hljs-string">'this.empty'</span> <span class="hljs-string">\</span>
        -<span class="hljs-built_in">print</span> FILE IS EMPTY
        </code></pre>
        <h3 id="-projections">-projections</h3>
        <p>Print list of supported proj4 projection ids and projection aliases.</p>
        <h3 id="-quiet">-quiet</h3>
        <p>Inhibit console messages.</p>
        <h3 id="-verbose">-verbose</h3>
        <p>Print verbose messages, including the time taken by each processing step.</p>
        <h3 id="-version">-version</h3>
        <p>Print mapshaper version.</p>


    </main>
    <footer class="site-footer">
        <div class="container">
            <div class="row">
                <div class="col-sm-12 col-md-5">

                    <ul class="footer-links">
                        <li>
                            <div class="contact-detail">
                                <h6 class="contact-type">General Inquiries</h6>
                                <p><a href="mailto:info@pinnisoft.com">info@aidenvironment.org</a>
                                </p>
                                <p></p>
                            </div>
                        </li>
                        <li>
                            <div class="contact-detail">
                                <h6 class="contact-type">Call us on</h6>
                                <p><a href="https://wa.link/d6r2ly"> +256 (0)393208817</a></p>
                            </div>
                        </li>
                        <li>
                            <h6 class="address-type">Physical address</h6>
                            <p><span class="z8gr9e">Plot 99 Luthuli Avenue, Kampala
                                    Uganda</span></p>
                        </li>
                    </ul>

                </div>

                <div class="col-xs-6 col-md-4" id="quick">
                    <h6>Categories</h6>
                    <ul class="footer-links">
                        <li><a href="#about">About Us</a></li>
                        <li><a href="https://aidenvironment.org/privacy-policy/">Privacy Policy</a></li>
                        <li><a href="https://aidenvironment.org/code-of-conduct/">Code of Conduct</a></li>
                        <li><a href="https://aidenvironment.org/contact/">Contact Us</a></li>
                    </ul>
                </div>

                <div class="col-xs-6 col-md-3" id="categories">
                    <h6>Quick Links</h6>
                    <ul class="footer-links">
                        <li><a href="command-reference.html">Command Reference</a></li>
                        <li><a href="command-line-tool.html">Command Line Tool</a></li>
                        <li><a href="topotopy.html">Topology</a></li>
                        <li><a href="tutoial.html">Tutorial</a></li>
                        <li><a href="web-interface.html">Web-interface</a></li>
                        <li><a href="using-shapefiles.html">Using Shapefiles</a></li>
                        <li><a href="simplification.html">Simplification</a></li>
                    </ul>
                </div>
            </div>
            <hr>
        </div>
        <div class="absolute-footer">
            <div class="row">
                <div class="col-md-4 col-sm-6 col-xs-12 logo">
                    <a class="navbar-brand" href="home.html">
                        <img src="assets/pics/aidlogo.png" alt="Logo" id="navbar-logo">
                        <!-- <span class="logo-text"> aid enviroment</span> -->
                    </a>
                </div>


                <div class="col-md-4 col-sm-6 col-xs-12">
                    <div>&copy; <span class="copyright-year">2023</span>
                        AidEnvironment. All rights reserved.
                        <span class="Links">
                            <a href="https://www.pinnisoft.com/#[object%20Object]" id="foot-link"
                                data-nls="footer-link-contact" target="_blank">PinniSOFT
                            </a>
                        </span>
                    </div>
                </div>

                <div class="col-md-4 col-sm-6 col-xs-12">
                    <ul class="social-icons">
                        <li><a class="facebook" href="https://facebook.com/aidenvironment">
                                <i class="fa-brands fa-facebook-f"></i>
                            </a>
                        </li>
                        <li><a class="twitter" href="https://www.twitter.com/aidenvironment">
                                <i class="fa-brands fa-x-twitter"></i></a>
                        </li>
                        <li><a class="dribbble" href="https://www.youtube.com/@aidenvironment7565">
                                <i class="fa-brands fa-youtube"></i></a>
                        </li>
                        <li><a class="linkedin" href="https://ug.linkedin.com/company/aidenvironment">
                                <i class="fa-brands fa-linkedin-in"></i>
                            </a>
                        </li>

                    </ul>
                </div>
            </div>

        </div>
    </footer>




    <script>
        document.addEventListener("DOMContentLoaded", function () {
            // Find the element that contains the copyright year
            var copyrightYearElement = document.querySelector(".copyright-year");

            if (copyrightYearElement) {

                var currentYear = new Date().getFullYear();


                copyrightYearElement.textContent = currentYear;
            }
        });
    </script>
    <script>
        // Activate Bootstrap navbar-toggler
        $(document).ready(function () {
            $('.navbar-toggler').on('click', function () {
                $(this).toggleClass('active');
            });
        });

        // Make the header sticky on scroll
        $(window).on('scroll', function () {
            if ($(window).scrollTop() > 100) {
                $('.navbar').addClass('sticky-header');
            } else {
                $('.navbar').removeClass('sticky-header');
            }
        });

        // Smooth scrolling for anchor links
        $('a[href^="#"]').on('click', function (e) {
            e.preventDefault();

            var target = this.hash;
            var $target = $(target);

            $('html, body').stop().animate({
                'scrollTop': $target.offset().top
            }, 800, 'swing', function () {
                window.location.hash = target;
            });
        });
    </script>
    <script src="assets/js/offcanvas.js"></script>

    <script src="assets/links/slim.min.js"></script>





</body>

</html>